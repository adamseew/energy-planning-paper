
%%
%% Energy-Aware Planning-Scheduling for Autonomous Aerial Robots 
%%

\documentclass[letterpaper,10pt,journal,twoside]{IEEEtran} 
%\IEEEoverridecommandlockouts 

\newcommand{\stt}[1]{{\small\tt #1}} %\small\tt too small here
\newcommand{\powprof}{\stt{powprofiler}}
\newcommand{\figpath}{./figures}
\newcommand{\iu}{{i\mkern1mu}}
\let\labelindent\relax

\usepackage[inline]{enumitem}
\usepackage{booktabs}
%\usepackage{flushend}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,decorations.pathreplacing,backgrounds}
%\usepackage[left=1in,right=1in,top=1in,bottom=1in]{geometry} 
\usepackage{pifont}

%% citation package
\usepackage{cite}

%% figures package
%\usepackage[pdftex]{graphicx}
%\graphicspath{{figures/}}
%\DeclareGraphicsExtensions{.pdf,.jpeg,.png}

%% math package
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{arydshln}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\let\proof\relax
\let\endproof\relax
\usepackage{amsthm}

%% pseudocode package
\usepackage{algorithm}
\usepackage[noend]{algorithmic}

% counter to maintain the line numbering
\newcommand{\setalglineno}[1]{%
  \setcounter{ALC@line}{\numexpr#1-1}}

%% packages for alignment
%\usepackage{array}
%\usepackage{mdwmath}
%\usepackage{mdwtab}
%\usepackage{eqparbox}

%% packages for subfigures (eventually)
%\usepackage[tight,footnotesize]{subfigure}
\usepackage[font=footnotesize]{caption}
\usepackage[font=footnotesize]{subcaption}
%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
%\usepackage[caption=false,font=footnotesize]{subfig}

%% package for urls
\usepackage{url}

%% hyperref
% and an override to make hyperref work with ieeeconf.cls
\makeatletter
\let\NAT@parse\undefined
\makeatother
\usepackage[pagebackref=true,breaklinks=true,colorlinks,bookmarks=false]{hyperref}
\makeatletter
\newcommand*{\textlabel}[2]{%
  \edef\@currentlabel{#1}% Set target label
  \phantomsection% Correct hyper reference link
  #1\label{#2}% Print and store label
}
\makeatother

\usepackage{textpos}

\DeclarePairedDelimiter\abs{\lvert}{\rvert}%
\DeclarePairedDelimiter\norm{\lVert}{\rVert}%

%% correct bad hyphenation here
\hyphenation{}

\renewcommand{\qedsymbol}{$\blacksquare$}

\theoremstyle{definition}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{assm}[thm]{Assumption}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}[section]
\newtheorem{defn}{Definition}[section]
\newtheorem{exmp}{Example}[section]
\newtheorem*{pb}{Problem}%[section]
\newtheorem{rem}{Remark}
\newtheorem{obs}{Observation}
\newtheorem*{ctb}{Contribution}

\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

% for blank page

%\usepackage{afterpage}

% for bibliography (double column balances)

%\usepackage{balance}

%% references (generates a bib file for bibtex)
%\begin{filecontents}{\jobname.bib}

%\end{filecontents}

\definecolor{c00FFFF}{RGB}{0,255,255}

\begin{document}
\bstctlcite{IEEEexample:BSTcontrol}

\title{Energy-Aware Planning-Scheduling for\\Autonomous Aerial Robots}

%% author names and affiliations
\author{
  Adam Seewald$^{\text{1}}$, H\'ector Garc\'ia de Marina$^{\text{2}}$, Henrik Skov Midtiby$^{\text{3}}$, and Ulrik Pagh Schultz$^{\text{3}}$
  \thanks{The work was partly funded by EU grant No. 779882 (TeamPlay). The work for H. G. is supported by the Ramon y Cajal grant No. RYC2020-030090-I.}
  \thanks{Manuscript received: Month, Day, Year; Revised Month, Day, Year; Accepted Month, Day, Year.}%Use only for final RAL version
  \thanks{This paper was recommended for publication by Editor Editor A. Name upon evaluation of the Associate Editor and Reviewers' comments.} %Use only for final RAL version
  \thanks{$^{\text{1}}$A. S. is with the Department of Mechanical Engineering and Material Science, Yale University, CT, USA, but the work was performed while affiliated with the SDU UAS. Email: {\tt\footnotesize \href{mailto:adam.seewald@yale.edu}{adam.seewald@yale.edu}};}
  \thanks{$^{\text{2}}$H. G. is with the Department of Computer Architecture and Technology and with CITIC, University of Granada, Spain;} 
  \thanks{$^{\text{3}}$H. S. M.,  U. P. S. are with the SDU UAS, %M{\ae}rsk Mc-Kinney M{\o}ller Institute, 
  University of Southern Denmark.}
  \thanks{Digital Object Identifier (DOI): see top of this page.}
}

\markboth{IEEE Robotics and Automation Letters. Preprint Version. Accepted Month, Year}
{Seewald \MakeLowercase{\textit{et al.}}: Planning-Scheduling for Aerial Robots} 
% Use only for final RAL version

%% make the title area
\maketitle
 
\vspace*{-5ex}

\begin{abstract}
  In this letter, we present an online planning-scheduling approach for battery-powered autonomous aerial robots. The approach consists of simultaneously planning a coverage path and scheduling onboard computational tasks. We further derive a novel variable coverage motion robust to airborne constraints and an empirically motivated energy model. The model includes the energy contribution of the schedule based on an automatic computational energy modeling tool. Our experiments show how an initial flight plan is adjusted online as a function of the available battery, accounting for uncertainty. Our approach furthermore remedies possible in-flight failure in case of unexpected battery drops, e.g., due to adverse atmospheric conditions, and increases the overall fault tolerance.
\end{abstract}

\vspace*{-.5ex}
\begin{IEEEkeywords}
  %Aerial Systems: Perception and Autonomy, %Optimization and Optimal Control, 
  %Planning, %Scheduling and Coordination, 
  %Planning under Uncertainty
  Motion and Path Planning, 
  Energy and Environ- ment-Aware Automation
\end{IEEEkeywords}

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle


\vspace*{-2.6ex}
%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}  %
\label{sec:intro}       %
                        %
\IEEEPARstart{U}{se cases} involving aerial robots span broadly. They comprise diverse planning and scheduling strategies and often require high autonomy under strict energy budgets. 
One such use case is coverage path planning (CPP)~\cite{choset2001coverage,galceran2013survey}, which consists of, e.g., an aerial robot visiting every point in a given space~\cite{cabreira2019survey} while running assigned computational tasks. Here, the aerial robot might detect ground patterns and notify other ground-based actors. %with little human interaction. 
Such use cases arise in %, e.g., 
precision agriculture~\cite{hajjaj2014review} 
where 
{\color{blue}information collection prior to an harvesting operation and}
%harvesting involves ground vehicles~\cite{%qingchun2012study,
%dong2011development, de2011design%,aljanobi2010setup, 
%li2008analysis, 
%edan2000robotic
%}, information collection prior to an operation as well as 
damage prevention during the operation involve aerial robots~\cite{puri2017agriculture, daponte2019review}.
Microcontrollers and heterogeneous computing hardware~\cite{mei2005case} (i.e., with CPUs and GPUs) running power-demanding computational tasks are frequently mounted onto the robots in these and many other scenarios~\cite{william2019aerial%, peng2019evaluating,
%wang2020yolo
,alexey2021autonomous}.
%In these and many others, the robot frequently mounts microcontroller and heterogeneous computing hardware~\cite{mei2005case} (i.e., with CPUs and GPUs) running power-demanding computational tasks~\cite{william2019aerial, peng2019evaluating,wang2020yolo,alexey2021autonomous}. 
We refer to onboard computational tasks that can be scheduled with an energy impact as \emph{computations}. We are interested in the energy optimization of motion plans and computations schedules in-flight and refer to it as energy-aware \emph{planning-scheduling}. 
The energy optimization of computations schedules can be achieved by, e.g., varying the quality of service between specific bounds~\cite{ho2019qos} and frequency and voltage of the computing hardware~\cite{mei2005case,brateman2006energy,zhang2007low}. We focus on the former aspect and schedule the onboard computations altering their quality while simultaneously changing the quality of the coverage.
{\color{blue} Concretely, we alter how often the aerial robot detects ground patterns along with the distance of the lines that form the coverage.}
Fig.~\ref{fig:il-abs} illustrates the intuition: an aerial robot flies a plan with maximal coverage and schedule~(\ref{sth:i}), that is optimized during flight to respect the battery state~(\ref{sth:ii}), and altered due to, e.g., unexpected battery defects~(\ref{sth:iii}).

\begin{figure}[t]
  \centering
  \vspace*{-9ex}
 %\begin{tikzpicture}
 %  \node[inner sep=0pt] () at (0,0)
        {\color{blue}\scriptsize \input{\figpath/il_abs_new.tikz}}
 %  \node[inner sep=0pt] () at (-2,-5.67)
 %      {\scriptsize \input{\figpath/il_abs_energy1.tikz}};
 %  \node[inner sep=0pt] () at (2.1,-5.67)
 %      {\scriptsize \input{\figpath/il_abs_spectrum1.tikz}};
 %\end{tikzpicture}
  \caption{%Illustrative example of planning-scheduling. 
  %The figure shows 
  An initial plan~(in~\ref{sth:i}) {\color{blue}is} re-planned online, changing the %resolution, 
  detection rate or other computational aspects~(in~\ref{sth:ii}) and %changing 
  the number of fly-bys or other motion aspects~(in~\ref{sth:iii}). 
  {\color{blue}Top-right} %shows 
  {\color{blue}are} the energy data of a physical fixed-wing aerial robot flying a static coverage plan similar to the one illustrated here{\color{blue}; below is }%. Bottom-right shows 
  the spectrum analysis, %of the %energy 
  %data, 
  revealing the periodicity %of the data 
  exploited in the %overall 
  energy model.
  %Follow the collected energy data of a physical aerial robot flying the static coverage.
  }
  \label{fig:il-abs}
  \vspace*{-4ex}
\end{figure}

There are numerous planning approaches applied to a variety of robots. An instance is an algorithm selecting an energy-optimized trajectory~\cite{mei2004energy} by, e.g., maximizing the operational time~\cite{wahab2015energy}. Many approaches apply to a small number of robots~\cite{kim2005energy} and focus exclusively on planning the trajectory~\cite{kim2008minimum}, despite compelling evidence of the energy influence of onboard consumptions~\cite{mei2005case,ondruska2015scheduled,sudhakar2020balancing,brateman2006energy}. In view of the availability of powerful heterogeneous computing hardware~\cite{rizvi2017general}, the use of onboard computations is further expected to increase in the foreseeable future~\cite{%abramov2012real,
%satria2016real,
jaramillo2019visual}. In this context, planning-scheduling energy awareness is a recent research direction% energy awareness for mobile robots are scarce
~\cite{brateman2006energy,sudhakar2020balancing,lahijanian2018resource,ondruska2015scheduled}. Early studies (2000--2010) varied hardware-dependent aspects, e.g., frequency, voltage, along with motion aspects, e.g., motor and travel velocities~\cite{mei2005case,brateman2006energy,zhang2007low,sadrpour2013mission} whereas the literature from the past decade derives energy-aware plans-schedules in broader terms. These include simultaneous considerations for planning-scheduling in perception~\cite{ondruska2015scheduled}, localization~\cite{lahijanian2018resource}, navigation~\cite{ho2019qos}, and anytime planning~\cite{sudhakar2020balancing}.
These studies are focused on ground-based robots~\cite{mei2005case,sadrpour2013mission,lahijanian2018resource,ondruska2015scheduled}, yet, aerial robots are particularly affected by energy considerations, as it would be generally required to land to recharge the battery. 
{\color{blue}In terms of aerial coverage, past work considers criteria including the completeness of the coverage and resolution~\cite{difranco2015energy}, and deals with aspects such as the quality of the cover~\cite{difranco2016coverage}, but neglects the energy expenditure of computations and favors rotary-wing aerial robots rather than aerial robots broadly.} 
Such a state of practice has prompted us to propose the planning-scheduling approach for autonomous aerial robots, combining the past body of knowledge but addressing aerial robots' peculiarities such as the atmospheric, battery, and turning radius constraints. Numerical simulations and experimental data of both static and dynamic plans and schedules show improved power savings and fault tolerance with the %aerial 
robot %s
remedying in-flight failures. 
 
Our focus is on fixed wings, i.e., airborne robots where wings provide lift, propellers provide forward thrust, and control surfaces perform maneuvering. Here, motion and computations energies are within an order of magnitude from each other~\cite{seewald2020mechanical}. %Indeed 
{\color{blue}T}here are other classes where planning-scheduling energy awareness leads to irrelevant savings, i.e., when the motion energy contribution far outreaches the computations or vice-versa. The {\color{blue}motion outreaching computation energy} frequently happens with rotary-wing aerial robots (e.g., quadrotors or quadcopters, hexacopters, etc.){\color{blue}, the opposite occurs with} lighter-than-air aerial robots (e.g., blimps). It is a common theme with wider planning-scheduling literature, focusing on energy-efficient ground-based robots such as Pioneer~3DX~\cite{ho2019qos,mei2005case}, ARC~Q14~\cite{ondruska2015scheduled,lahijanian2018resource}, and Pack-Bot~UGV~\cite{sadrpour2013mission}.
%\begin{ctb}
%  We extend the literature on planning-schedu- ling to CPP with aerial robots, model the overall and computations energies and battery evolution, and derive a variable coverage motion for constrained systems, e.g., fixed wings.
%\end{ctb}

To guarantee energy awareness, our approach uses optimal control {\color{blue} and heuristics} where both the paths and schedules variations are trajectories, varying between given bounds (i.e., physical constraints of the robot and computing hardware, quality of service, desired quality of the coverage, etc.). Past planning-scheduling studies also employ optimization techniques~\cite{brateman2006energy,zhang2007low,ondruska2015scheduled,lahijanian2018resource}; some use a greedy approach~\cite{mei2005case,sudhakar2020balancing,sadrpour2013mission}; whereas others use reinforcement learning-based approaches~\cite{ho2019qos,ho2018towards}. {\color{blue}Hybrid approaches~\cite{ondruska2015scheduled} are also available, where the techniques are mixed.} Both the path and schedules variations trajectories are derived for future time instants employing computations and overall energies and battery models. The energy model for the computations uses regressional analysis from our earlier study on heterogeneous computing hardware% energy modeling
~\cite{seewald2019coarse,seewald2019component}, whereas the battery uses an equivalent circuit model (ECM) from the literature~\cite{%he2011evaluation,
hinz2019comparison,mousavi2014various}. The overall model wraps these two aspects in a cohesive model that uses dynamics modeling to predict the energy behavior of future plans and schedules. In Fig.~\ref{fig:il-abs}, collected energy data ({\color{blue}top-right}) and spectrum analysis ({\color{blue}below}) of a fixed wing %aerial robot 
flying CPP motivates the overall energy model: the evolution is periodic--CPP often involves repetitive motions to cover the space~\cite{choset2001coverage,galceran2013survey}--an observation exploited in Section~\ref{sec:energy-model}.% for the computations and motion energies and battery models.

The %remaining sections of the letter are 
{\color{blue}remainder is} then organized as follows. Section~\ref{sec:prob} provides basic constructs%, such as the concepts of the stages, path functions, triggering and final points, and plan, as well as 
{ \color{blue}and} %the problem formulation.
Section~\ref{sec:algo} describes %in detail 
the methodology of planning-scheduling. Section~\ref{sec:experimental} presents the results, %and showcases the performances, 
and Section~\ref{sec:conclusion} concludes and provides future perspectives. %Appendices~\ref{app:proof-eqv}--\ref{app:proof-bat} provide supplementary material.

\vspace*{-1ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problem Formulation}  %
\label{sec:prob}               %
                               %
%Before defining the problem of energy-aware planning-scheduling in Section~\ref{sec:pbfor}, Section~\ref{sec:prelim} provides necessary preliminaries. 
%For CPP and, e.g., pattern detections in precision agriculture, 
{\color{blue}W}e assume %that %aerial 
{\color{blue}the }robot contains a \emph{plan} composed of \emph{stages}. At each, %stage, %the aerial robot 
{\color{blue}it }travels a path and runs a schedule on the computing hardware. Both are %to be 
altered in Section~\ref{sec:algo} within given boundaries with \emph{path}- and \emph{computation}-specific \emph{parameters}.%with information about the path and the schedule.

\begin{figure}[t]
  \footnotesize
  \begin{minipage}[l]{0.38\columnwidth}
    \caption{Definitions~\ref{def:stage}--\hyperref[def:plan]{4} on a slice of the plan $\Gamma$. $\mathbf{p}_{\Gamma_i}$ are triggering points in which proximity happens change of stages $\Gamma_i$. Each contains a path function $\varphi_i$ and parameters to alter the path and schedule $c_{i,1},\dots$.}
    \label{fig:traj1}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.6\columnwidth}
    \centering
    \vspace*{-4ex}
    \input{\figpath/new/traj1.tikz}
  \end{minipage}
  \vspace*{-4.5ex}
\end{figure}

\vspace*{-2ex}
\subsection{Preliminaries}
\label{sec:prelim}

%Here, $\Gamma_i$ is a \emph{stage}, $\varepsilon_i$ is a stage-dependent value detailed 
%along with $\mathbf{p}_{\Gamma_i}$ in and 
%after Definition~\ref{def:trigs}.

\begin{defn}[Stage]\label{def:stage}
  Given a generic point $\mathbf{p}\in\mathbb{R}^2$ w.r.t. a reference frame $\mathcal{O}_W$ of the aerial robot flying at a given altitude $h\in\mathbb{R}_{>0}$, the $i$th \emph{stage} $\Gamma_i$ %at time instant $t$ %of a plan $\Gamma$ 
  is
  \begin{equation*}\begin{split}
    \Gamma_i:=\{{\color{blue}\varphi_i(\mathbf{p}%(t)
    ,c_i^\rho)},c_i^\sigma\mid
    \,&\forall j\in\,[\rho]_{>0},\,c_{i,j}\,\,\,\,\,\,\,\in\mathcal{C}_{i,j},\,\\
      &\forall k\in[\sigma]_{>0},\,c_{i,\rho+k}\in\mathcal{S}_{i,k}\,\},
  \end{split}\end{equation*}
  where $c_i^\rho${\color{blue}$:=\{c_{i,1},c_{i,2},\dots,c_{i,\rho}\}$} and $c_i^\sigma${\color{blue}$:=\{c_{i,\rho+1},c_{i,\rho+2},\dots,$ $c_{i,\rho+\sigma}\}$} are $\rho$ \emph{path} and $\sigma$ \emph{computation parameters}{\color{blue}, e.g., $c_i^\rho:=\{c_{i,1}\}$ is a value that changes the distance of the coverage lines and $c^\sigma_i:=\{c_{i,2}\}$ the detection rate with $\rho$ and $\sigma$ being one (see Section~\ref{sec:experimental})}. $\mathcal{C}_{i,j}:=[\underline{c}_{i,j},\overline{c}_{i,j}]\subseteq\mathbb{R}$ is the $j$th path parameter %$c_{i,j}$ 
  constraint set, %and 
  $\mathcal{S}_{i,k}:=[\underline{c}_{i,\rho+k},\overline{c}_{i,\rho+k}]\subseteq\mathbb{Z}_{\geq 0}$ %is 
  the $k$th computation parameter constraint set. {\color{blue}Indices $j,k$ serves~to~differentiate path and computation parameters constraints and indicate that each parameter can have a different constraint set.} 
\end{defn}


For a set $\mathbb{X}$, $\mathbb{X}_{\geq 0}$ indicates its members are positive, $\mathbb{X}_{> 0}$ strictly positive, and $|\mathbb{X}|$ its cardinality. $\mathbb{Z},\mathbb{R}$ are %the sets of 
integers and reals. % respectively.
Bold letters indicate vectors. 
The notation $[x]$ denotes positive naturals up to $x$, i.e., $\{0,1,\dots,x\}$, {\color{blue}$[x]_{>0}$ strictly positive naturals, i.e., $\{1,2,\dots,x\}$,} $x'$ the transpose of $x$, and $[\underline{x},\overline{x}]$ the upper/lower bounds of %a parameter 
$x$, i.e.,
%\begin{equation}
  $\underline{x}\leq x\leq\overline{x}$.
%\end{equation}

The function $\varphi_i$ is a \emph{path function}{\color{blue}--a }%specifying the path. These are 
stage-dependent mathematical function %s 
the %aerial 
robot tracks as it travels %the motion for 
the coverage. 

\begin{defn}[Path functions]
  \label{def:paths}
  $\varphi_i:\mathbb{R}^2\times\mathbb{R}^\rho\rightarrow\mathbb{R},\,\forall i\in\{1,2,\dots\}
  $ are \emph{path functions}, forming the path. They are a function of {\color{blue}$\mathbf{p}%(t)
  $} and path parameters $c_i^\rho%(t)
  $ and are continuous.% and twice differentiable.
\end{defn}

The change of stages happens in the proximity of given points termed \emph{triggering points}, whereas the plan is complete at the occurrence of the \emph{final point}.

\begin{defn}[Triggering and final points]
  \label{def:trigs}
  The \emph{triggering point} $\mathbf{p}_{\Gamma_{i}}$ describes the transition between stages. \emph{Final point} is the last triggering point $\mathbf{p}_{\Gamma_{l}}$ relative to the last stage $\Gamma_l$.
\end{defn}

The plan merges the concepts from Definitions~\ref{def:stage}--\hyperref[def:trigs]{3}. %via a .

\begin{defn}[Plan]\label{def:plan}
  The \emph{plan} is a finite state machine (FSM) $\Gamma$, where the state-transition function $s:\bigcup_i{\Gamma_i}\times\mathbb{R}^2\rightarrow\bigcup_i{\Gamma_i}$ maps a stage and a point to the next stage
  \begin{equation*}{\color{blue}s(\Gamma_i,\mathbf{p}%(t)
    )}:=\begin{cases}
    \Gamma_{i+j} & {\color{blue}\text{if }\norm{\mathbf{p}%(t)
    -\mathbf{p}_{\Gamma_i}}<\varepsilon_i,\,\exists j\in\mathbb{Z},}\\
    \Gamma_i & \text{otherwise}.
  \end{cases}\end{equation*}
\end{defn}

The stage-dependent value $\varepsilon_i\in\mathbb{R}_{\geq 0}$ in Definition~\ref{def:plan} expresses the radius of a non-existent circle over $\mathbf{p}_{\Gamma_i}$.

Fig.~\ref{fig:traj1} illustrates the concepts in Definitions~\ref{def:stage}--\hyperref[def:plan]{4}. $\varphi_0,\dots,\varphi_5$ are path functions. $\varphi_0$ and $\varphi_4$ are circles, while $\varphi_1$, $\varphi_3$, and $\varphi_5$ are lines. They are relative to different stages $\Gamma_1,\dots$ but $\Gamma_0$ (the starting stage) and are changed in the proximity of $\mathbf{p}_{\Gamma_0},\dots$. %The constraint set $\mathcal{C}_{4,1}$ forms the area where 
It is possible to alter the paths $\varphi_1,\dots,\varphi_4$ with the parameters $c_{1,1},\dots,c_{4,1}$--%illustrated by 
the gray area.% in the figure. %The area relative to $\Gamma_5$ is bounded by $\underline{c}_{5,1}\overline{c}_{5,1}$.

A convenient way of defining $\Gamma$ is specifying a set of stages, a shift, and a final point. The set is termed \emph{primitive stages} and iterated with the shift up to reaching the final point.

\begin{defn}[Primitive stages]
  \label{def:primitive}
  Given the number of \emph{primitive stages} $n\in\mathbb{Z}_{>0}$, a \emph{shift} $\mathbf{d}\in\mathbb{R}^2$, and a final point $\mathbf{p}_{\Gamma_l}$, the stages $\Gamma_1,\Gamma_2,\dots,\Gamma_n$ %with the path functions $\varphi_1,\dots\varphi_n$ and the parameters $c_1,c_2,\dots,c_n$ 
  are \emph{primitive} if they form the remainder of the plan with $\mathbf{d}$ up to $\mathbf{p}_{\Gamma_l}$. 
\end{defn}
\noindent In this case, the path functions have a constant distance $e_j$ per each value in $[n]_{>0}$, i.e., 
\begin{equation}\label{eq:primitive}\begin{split}
  &\varphi_{(i-1)n+j}(\mathbf{p}+(i-1)\mathbf{d},c_1^\rho)-\varphi_{in+j}(\mathbf{p}+i\mathbf{d},c_1^\rho)=e_j,
\end{split}\end{equation}
holds $\forall i\in[l/n-1]_{>0},j\in[n]_{>0}$ assuming the total number of stages is known and is $l\in\mathbb{Z}_{>0}$. $e_j\in\mathbb{R}$ given a shift $\mathbf{d}$, initial point $\mathbf{p}$, and initial value of path parameters $c_1^\rho$.

\begin{figure}[h!]
  \footnotesize
  \begin{minipage}[l]{0.75\columnwidth}
    \vspace*{-2.7ex}
    \begin{tikzpicture}[shorten >=.3pt,node distance=12.5ex,on grid,auto,initial text=\hspace*{-.8ex}\footnotesize{$\Gamma_0$}\hspace*{-.5ex}]
      \scriptsize
      \node[state,initial] (q_i) {$\Gamma_1$}; 
      \node[state] (q_2) [right=of q_i] {$\Gamma_2$}; 
      \node        [right=of q_2] (q_dots0) {$\cdots$};
      \node[state] (q_0) [right=of q_dots0] {$\Gamma_n$};
      \node[state,accepting] (q_f) [right=of q_0] {$\Gamma_f$};
      \path[->]
      (q_i) edge node {$\mathbf{p}_{\Gamma_{1}}$} (q_2)
      (q_2) edge node {$\mathbf{p}_{\Gamma_{2}}$} (q_dots0)
      (q_dots0) edge node{$\mathbf{p}_{\Gamma_{n-1}}$} (q_0)
      (q_0) edge [bend right=60] node [above] {$\mathbf{p}_{\Gamma_n}$} (q_i)
      (q_i) edge [bend left=-60] node [above] {$\mathbf{p}_{\Gamma_l}$} (q_f)
      (q_2) edge [bend left=-40] node [above] {$\mathbf{p}_{\Gamma_l}$} (q_f)
      (q_0) edge node {$\mathbf{p}_{\Gamma_{l}}$} (q_f)    
      (q_i) edge [loop above] node {$\mathbf{p}(t_1)$} (q_i)
      (q_2) edge [loop above] node {$\mathbf{p}(t_2)$} (q_2)
      (q_0) edge [loop above] node {$\mathbf{p}(t_3)$} (q_0)
      (q_f) edge [loop above] node {$\mathbf{p}(t_4)$} (q_f)
      ; %end path 
      %\draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=47pt},yshift=0pt]
      %(q_i.south west) -- (q_f.south west) node [black,midway,yshift=-19ex]{$\Gamma$};
    \end{tikzpicture}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.18\columnwidth}
    \centering
    \caption{Plan $\Gamma$ with $n$ primitive stages in Def.~\ref{def:primitive}.}
    \label{fig:state-machine-loop}
  \end{minipage}
  \vspace*{-4ex}
\end{figure}
%\begin{figure}[h!]
%  \center
%  \vspace*{-2.2ex}
%  \begin{tikzpicture}[shorten >=.5pt,node distance=12.5ex,on grid,auto,initial text=\hspace*{-3ex}\footnotesize{$\Gamma_0$}]
%    \scriptsize
%    \node[state,initial] (q_i) {$\Gamma_1$}; 
%    \node[state] (q_2) [right=of q_i] {$\Gamma_2$}; 
%    \node        [right=of q_2] (q_dots0) {$\cdots$};
%    \node[state] (q_0) [right=of q_dots0] {$\Gamma_n$};
%    \node[state,accepting] (q_f) [right=of q_0] {$\Gamma_f$};
%    \path[->]
%    (q_i) edge node {$\mathbf{p}_{\Gamma_{1}}$} (q_2)
%    (q_2) edge node {$\mathbf{p}_{\Gamma_{2}}$} (q_dots0)
%    (q_dots0) edge node{$\mathbf{p}_{\Gamma_{n-1}}$} (q_0)
%    (q_0) edge [bend right=60] node [above] {$\mathbf{p}_{\Gamma_n}$} (q_i)
%    (q_i) edge [bend left=-60] node [above] {$\mathbf{p}_{\Gamma_l}$} (q_f)
%    (q_2) edge [bend left=-40] node [above] {$\mathbf{p}_{\Gamma_l}$} (q_f)
%    (q_0) edge node {$\mathbf{p}_{\Gamma_{l}}$} (q_f)    
%    (q_i) edge [loop above] node {$\mathbf{p}(t_1)$} (q_i)
%    (q_2) edge [loop above] node {$\mathbf{p}(t_2)$} (q_2)
%    (q_0) edge [loop above] node {$\mathbf{p}(t_3)$} (q_0)
%    (q_f) edge [loop above] node {$\mathbf{p}(t_4)$} (q_f)
%    ; %end path 
    %\draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=47pt},yshift=0pt]
    %(q_i.south west) -- (q_f.south west) node [black,midway,yshift=-19ex]{$\Gamma$};
%  \end{tikzpicture}
%  \vspace*{-2.3ex}
%  \caption[Definition of a plan with a loop]{Definition of a plan $\Gamma$ with periodic patterns. Stages $\Gamma_1,\Gamma_2,\dots,\Gamma_n$ containing primitive paths $\varphi_1,\varphi_2,\dots,\varphi_n$ are iterated with a shift $\mathbf{d}$.}
%  \vspace*{-1ex}
%  \label{fig:state-machine-loop}
%\end{figure}

Fig.~\ref{fig:state-machine-loop} illustrates the concept. %s in Definition~\ref{def:primitive}. 
A plan composed of $n$ stages $\Gamma_1,\dots,\Gamma_n$ (%containing 
{\color{blue}with }primitive paths $\varphi_1,\dots,\varphi_n$) is reiterated with the shift $\mathbf{d}$. $t_1<\dots<t_4$ are time instants $\in\mathbb{R}_{> 0}$. $\Gamma_f$ is the accepting stage, indicating the plan is complete, $\Gamma_0$ the initial stage where the aerial robot awaits the starting command.

\vspace*{-.7ex}
\subsection{Energy-aware planning-scheduling problem}
\label{sec:pbfor}

The problem %of planning-scheduling 
is {\color{blue}split into }%composed of 
%two%sub-problems.
{\color{blue}the derivation }%. One is 
%to form a %static 
{\color{blue} of} a {\color{blue}coverage} plan %that visits every point in space 
{\color{blue}and its} {\color{blue}energy-aware} %other to
re-plan{\color{blue}ing}~and~-schedul{\color{blue}ing~}%the plan 
in-flight.~The %in an energy-aware way. %{\color{blue}, whereas }
{\color{blue} 
re-planning-scheduling improves a performance metric--%, which is %quality of the plan and schedule against battery state of charge (SoC), i.e., the 
the weighted average of parameters divided by the remaining battery state of charge (SoC), both in percent (e.g., $\underline{c}_{i,j}$, $\overline{c}_{i,j}$ correspond to 0 and 100). The objective is~%then 
high~average~parame- ters configuration and battery usage with successful %area 
coverage.
%The performance metric the re-planning-scheduling %in the letter 
%improves is %then
%the quality of the plan-schedule against battery state of charge (SoC), e.g., weighted average value of parameters divided by remaining %battery 
%SoC.% at the end of the flight.
}\vspace*{-2.7ex}

\begin{pb}[Coverage and re-planning-scheduling problem]
  \label{pb:cov-pb}
  Consider a finite set of vertices of a polygon $v:=\{v_1,v_2,\dots\}$ where each %vertex $v_i:=(x_{v_i},y_{v_i})%,\forall i\in[|v|]_{>0}$
  %,\,o_{j,k}:=(x_{o_{j,k}},y_{o_{j,k}}),\,\forall j\in|o|,k\in|o_j|$ 
  is a point w.r.t. $\mathcal{O}_W$. 
  Let $\underline{r}\in\mathbb{R}_{\geq 0}$, the vehicle's turning radius, and $\mathbf{p}(t_0)$, the starting point at the time instant $t_0$, be given. 
  The \emph{coverage problem} is the problem of finding a plan $\Gamma$ to cover the polygon, whereas the \emph{re-planning-scheduling problem} is finding the {\color{blue}energy-aware} trajectory of parameters $c_i$ in time{\color{blue}, optimizing battery SoC}.
\end{pb}    

%, i.e, $|\mathbb{X}|:=\sum_{x\in\mathbb{X}}1$
%.

%\begin{pb}[Re-planning-scheduling problem]
%  \label{pb}
%  Consider an initial plan $\Gamma$ in Definition~\ref{def:plan}. The \emph{re-planning-scheduling problem} is the problem of finding the optimal configuration of path and computations parameters $c_i(t),\,\forall i\in\{1,2,\dots\}$ under energy constraints and uncertainty at each time step $t$.
%\end{pb}

Here, $c_i$ denotes a row vector with both the path and computation parameters in sequence, i.e., $c_i:=[\begin{matrix}\,c_i^\rho & c_i^\sigma\,\end{matrix}]'$. %The notation .


%The algorithm inputs a user-specified initial plan that consist of different stages. At each stage the plan contains some parameters that allow to alter the path and computations along an energy budget. The alterations are bounded. There is one path constraint set which bounds the path and multiple computation constraint sets, one per each computation parameter, that bound computations. In Fig.~\ref{fig:il-abs}, there are two parameters. One relative to the path (\ref{sth:ii}~has a shorter distance between the lines than~\ref{sth:iii}), and the other one to the computations (\ref{sth:i}~processes more images per second than~\ref{sth:ii}). 

%The algorithm outputs the control (the parameters) using model predictive control (MPC)~\cite{rawlings2017model} where it checks the satisfaction of the battery constraints. The control is data-driven. Energy sensor data estimates some coefficients of an energy model used to predict future energy consumption in presence of uncertainty. The energy budget is the battery capacity and other battery parameters. These are fixed values that are not replanned by the algorithm. Our goal is to complete the plan with the highest possible parameters configuration as the UAV flies and its batteries drain. 

%\subsection{Plan definition}
%\label{sec:prelim}

%Let us adopt the following mathematical notation. Given an integer $a$, $[a]$ is the set $\{0,1,\dots,a\}$, $[a]^+$ the set $[a]/\{0\}$. Bold lower-case letters indicates vectors. $c_{i,j}$ the $j$-th parameter of the $i$-th parameters set $c_i$. $\underline{c}_{i,j},\overline{c}_{i,j}$ are the lower and upper bounds of the parameter $c_{i,j}$.

%Let us assume that the path at stage $i$ can be altered with $\rho$ path parameters $c_i^\rho:=\{c_{i,1},c_{i,2},\dots,c_{i,\rho}\}$, and the computations with $\sigma$ computation parameters $c_i^\sigma:=\{c_{i,\rho+1},c_{i,\rho+2},\dots,c_{i,\rho+\sigma}\}$. We then express the path as a continuous twice differentiable function $\varphi_i:\mathbb{R}^2\times\mathbb{R}^\rho\rightarrow\mathbb{R}$ of a point and the path parameters. The function returns a metric of the distance between the point and the nominal trajectory. We express the computations as the value of the computation parameters. We discuss the concrete meaning of the value of path parameters in Subsection~\ref{sec:model}, and computation parameters in Subsection~\ref{sec:computations-model}.

%\begin{defn}[Stage, plan, triggering, and final point]\label{def:mission}
%  The $i$-th \emph{stage} $\Gamma_i$ at time instant $k$ of a plan $\Gamma$ is defined
%  \begin{equation*}\begin{split}
%    \Gamma_i:=\{\varphi_i(\mathbf{p}_k,c_i^\rho),c_i^\sigma\mid
%    \,&\exists\,\,\mathbf{p}_k,\,\varphi_i(\mathbf{p}_k,c_i^\rho)\in\mathcal{C}_i,\,\\
%      &\,\forall j\in[\sigma]^+,\,c_{i,\rho+j}\in\mathcal{S}_{i,j}\,\},
%\end{split}\end{equation*}
%where $\mathcal{C}_i:=[\underline{c}_i,\overline{c}_i]\subseteq\mathbb{R}$ is the path constraint set, and $\mathcal{S}_{i,j}:=[\underline{c}_{i,\rho+j},\overline{c}_{i,\rho+j}]\subseteq\mathbb{Z}_{\geq 0}$ the $j$-th computation constraint set. $\mathbf{p}_k$ is a point of a UAV flying at an altitude $h\in\mathbb{R}_{>0}$
%\footnote{The altitude might change at different flying phases and under different atmospheric conditions}
%w.r.t. some inertial navigation frame $\mathcal{O}_W$.   
  
%In Fig.~\ref{fig:traj1}, $\varphi_1,\dots,\varphi_6$ are paths. $\varphi_1$ and $\varphi_5$ are circles, while $\varphi_2$, $\varphi_4$, and $\varphi_6$ are lines. They are all relative to different stages $\Gamma_1,\Gamma_2,\dots$. The constraints set $\mathcal{C}_1,\mathcal{C}_2,\dots$ forms the area where the paths $\varphi_1,\varphi_2,\dots$ can be altered with the parameters $c_{i,1},\dots,c_{i,\rho}$ (gray area in the figure). This area is bounded by $\underline{c}_i,\overline{c}_i$, and can be different per each stage (in Fig.~\ref{fig:traj1}, the area relative to $\Gamma_4$ is bounded by $\underline{c}_4,\overline{c}_4$).

%The \emph{plan} is a finite state machine (FSM) $\Gamma$ where the state-transition function $s:\bigcup_i{\Gamma_i}\times\mathbb{R}^2\rightarrow\bigcup_i{\Gamma_i}$ maps a stage and a point to the next stage
%\begin{equation*}s(\Gamma_i,\mathbf{p}_k):=\begin{cases}
%  \Gamma_{i+1} & \text{if }\mathbf{p}_k=\mathbf{p}_{\Gamma_i}\\
%  \Gamma_i & \text{otherwise}
%\end{cases}.\end{equation*}
%The point $\mathbf{p}_{\Gamma_{i}}$ that allows the transition between $\Gamma_i$ and $\Gamma_{i+1}$ is called \emph{triggering point}. In Fig.~\ref{fig:traj1}, $\mathbf{p}_{\Gamma_1}$ allows the transition between $\Gamma_1$ and $\Gamma_2$, $\mathbf{p}_{\Gamma_4}$ between $\Gamma_4$ and $\Gamma_5$, and $\mathbf{p}_{\Gamma_5}$ between $\Gamma_5$ and $\Gamma_6$. The last triggering point $\mathbf{p}_{\Gamma_{l}}$ relative to the last stage $\Gamma_l$ is called \emph{final point}.
%\end{defn}

%\begin{figure}[h]
%  \center
%  \begin{tikzpicture}[shorten >=.5pt,node distance=10.5ex,on grid,auto]
%    \footnotesize
%    \node[state,initial] (q_i) {$\Gamma_1$}; 
%    \node        [right=of q_i] (q_dots0) {$\cdots$};
%    \node[state] (q_0) [right=of q_dots0] {$\Gamma_i$};
%    \node        (q_dots1) [right=of q_0] {$\cdots$};
%    \node[state,accepting] (q_f) [right=of q_dots1] {$\Gamma_f$};
%    \path[->]
%    (q_i) edge node {$\mathbf{p}_{\Gamma_{1}}$} (q_dots0)
%    (q_dots0) edge node{$\mathbf{p}_{\Gamma_{i-1}}$} (q_0)
%    (q_0) edge node {$\mathbf{p}_{\Gamma_i}$} (q_dots1)
%    (q_dots1) edge node {$\mathbf{p}_{\Gamma_{l}}$} (q_f)    
%    (q_i) edge [loop above] node {$\mathbf{p}_{k_1}$} (q_i)
%    (q_0) edge [loop above] node {$\mathbf{p}_{k_2}$} (q_0)
%    (q_f) edge [loop above] node {$\mathbf{p}_{k_3}$} (q_f)
%    ; %end path 
%    \draw [decorate,decoration={brace,amplitude=10pt,mirror,raise=10pt},yshift=0pt]
%    (q_i.south west) -- (q_f.south west) node [black,midway,yshift=-9ex]{$\Gamma$};
%  \end{tikzpicture}
%  \caption{The plan defined as a FSM}
%  \label{fig:state-machine}
%\end{figure}

%A slice of the plan in Fig.~\ref{fig:state-machine} shows the transition between the stages with the FSM. The triggering point $\mathbf{p}_{\Gamma_{i-1}}$ allows the transition to the stage $\Gamma_i$. The UAV remains in the stage with any generic point $\mathbf{p}_{k_2}$. It eventually enters the stage $\Gamma_{i+1}$ with the triggering point $\mathbf{p}_{\Gamma_i}$ and so on, until it reaches the final point. The stage $\Gamma_f$ is the accepting stage (it indicates that the UAV has completed the plan).

%\begin{figure}[h]
%  \center
%  \begin{tikzpicture}[shorten >=1pt,node distance=23ex,on grid,auto] 
%    \node        (q_dots0) {$\cdots$};
%    \node[state] (q_0) [right=of q_dots0] {$\Gamma_i$};
%    \node        (q_dots1) [right=of q_0] {$\cdots$};   
%    \path[->]
%    (q_dots0) edge node{$\mathbf{p}_{\Gamma_{i-1}}(c_1^\rho,\dots,c_{i-1}^\rho)$} (q_0)
%    (q_0) edge node {$\mathbf{p}_{\Gamma_i}(c_1^\rho,\dots,c_{i}^\rho)$} (q_dots1)    
%    (q_0) edge [loop above] node {$\mathbf{p}_{k}$} (q_0)
%    ; %end path
%  \end{tikzpicture}
%  \caption{Detail of the stage $\Gamma_i$ in the FSM}
%  \label{fig:state-machine2}
%\end{figure}

%Generally, one can express the triggering points in function of the $i$-th trajectory parameters $c_{i}^{\rho}$, or any previous trajectory parameters, propagating the information therein if necessary (see Fig.~\ref{fig:state-machine2}).

%We refer the reader to an example in Appendix~\ref{app:plan-example} for a detailed implementation. In the example, the first trajectory parameter is propagated to all the following trajectories and triggering points. 

%We store the initial plan in the plan specification, the format is described in Appendix~\ref{app:plan-spec}. 

%\subsection{Problem formulation}

%In order to simplify the problem formulation, we consider some primitive paths. All the other paths are built from these paths with a shift $\mathbf{d}:=(x_d,y_d)$.

%Given $n\in\mathbb{Z}_{>0}$ ($n<l,l/n\in\mathbb{Z}$) primitive paths $\varphi_1,\dots\varphi_n$, a generic starting point $\mathbf{p}$ and the current levels of the path parameters $c_1^\rho$, all the other paths $\varphi_{n+1},\dots,\varphi_l$ are built
%\begin{equation}\label{eq:primitive}\begin{split}
%  &\varphi_{(i-1)n+j}(\mathbf{p}+(i-1)\mathbf{d},c_1^\rho)-\\ &\,\,\,\varphi_{in+j}(\mathbf{p}+i\mathbf{d},c_1^\rho)=e_j,
%\end{split}\end{equation}
%$\forall i\in[l/n-1]^+,j\in[n]^+$, where $e_j\in\mathbb{R}$ is the $j$-th constant difference.

%\begin{defn}[Period]\label{def:period}
%  The period $T\in\mathbb{R}_{> 0}$ is the time between $\varphi_{(i-1)n+j}$ and $\varphi_{in+j}$ in Eq.~(\ref{eq:primitive}).
%\end{defn} 

%The algorithm measures the time between the paths and assumes the initial period is one. The periods might be different for different $j$s due to atmospheric interferences.

%One can define the plan using primitive paths or define all the stages explicitly and find $n$ searching the value which satisfies the Eq.~(\ref{eq:primitive}). If there is no such value, (e.g., when the plan is composed of only one stage), the period $T$ from Definition~\ref{def:period} can be determined empirically from energy data (such as these shown in Fig.~\ref{fig:il-abs}).

%\begin{pb}[UAV planning problem]\label{pb}
%  Consider an initial plan $\Gamma$ from Definition~\ref{def:mission}. We are interested in the planning of the parameters $c_i,\,\forall i\in[l]^+$ and energy constraints and in the guidance of the UAV to the path resulting from such plan.
%\end{pb}


%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Energy Models}  %
\label{sec:energy-model} %
                         %
The solution to the problem requires energy models, predicting the impact of changes to path and computation parameters on the battery. %at future time instants. To this end, 
Sections~\ref{sec:mod-mot}--\hyperref[sec:mod-bat]{C} provide models for the overall and computations energies {\color{blue}and }%as well as 
battery evolution.

\subsection{Overall energy model% for the motion
}
\label{sec:mod-mot}

The collected energy data and corresponding spectrum analysis in Fig.~\ref{fig:il-abs} show the energy of a static coverage plan. It is relative to one flight of a series of flights for CPP exhibiting periodic behavior in a precision agriculture use case~\cite{seewald2020mechanical}. %$\Gamma$ with four primitive path functions iterated with a shift. 
Assuming the primitive paths have approximately the same length and the aerial robot has a fixed ground speed, the data exhibits periodic behavior with a constant set of frequencies, independent of the shift. The hypothesis is further backed by the power spectrum analysis, indicating that to model the energy, three frequencies are adequate.

%We refer to the instantaneous energy consumption evolution simply as the energy signal. We model the energy using energy coefficients $\mathbf{q}\in\mathbb{R}^m$ that characterize such energy signal. The coefficients are derived from Fourier analysis (the size of the energy coefficients vector $m$ is related to the order of a Fourier series) and estimated using a state estimator. %(Kalman filter); well, potentially here with simulated data one could use other estimators (least square filter would work I bet) 

%We prove a relation between the energy signal and the energy coefficients in Lem.~\ref{lem:eqv}. We show after the main results how this approach allows us variability in terms of non-periodic signals.

%After having illustrated the energy model, we enhance it with the energy contribution of the path in Subsection~\ref{sec:model}, and of the computations in Subsection~\ref{sec:computations-model}. 

An intuitive way of modeling the energy data is a Fourier series of a given order $r\in\mathbb{Z}_{\geq 0}$ and period $T\in\mathbb{R}_{>0}$
\begin{equation}\label{eq:fourier}
  h(t)=a_0/T+(2/T)\sum_{j=1}^{r}{\left(a_j\cos{\omega jt}+b_j\sin{\omega jt}\right)},
\end{equation}
where $h:\mathbb{R}_{\geq 0}\rightarrow\mathbb{R}$ maps time to the instantaneous energy% consumption
, $\omega:=2\pi/T$ is the angular frequency, and $a,b\in\mathbb{R}$ %the %series 
coefficients.

%The model in 
Equation~(\ref{eq:fourier}) does not account for the variation of parameters, where, e.g., two schedules result in different instantaneous energies.
%The model in Equation~(\ref{eq:fourier}) does not quantify the contribution of path and computations parameters $c_i$, where, e.g., different schedules result in different instantaneous energy. 
For this latter purpose, we use the dynamics %another model
\begin{subequations}\label{eq:state-perf}
  \begin{align}
  \dot{\mathbf{q}}(t)&=A\mathbf{q}(t)+B\mathbf{u}(t),\label{eq:state-perf-q}\\
  y(t)&=C\mathbf{q}(t),\label{eq:state-perf-y}
\end{align}
\end{subequations}
where $y(t)\in\mathbb{R}$ is the instantaneous energy consumption. The state $\mathbf{q}\in\mathbb{R}^m$ with $m:=2r+1$ contains energy coefficients
\begin{equation}
  \mathbf{q}(t)=\begin{bmatrix}
    \alpha_0(t) & \alpha_1(t) & \beta_1(t) & \cdots & \alpha_r(t) & \beta_r(t)
  \end{bmatrix}'.
\end{equation}

The state transition matrix
\begin{equation}\label{eq:mat_A}{\small
  A=\begin{bmatrix}
    0            & 0^{1\times 2}& \dots & 0^{1\times 2} \\
    0^{2\times 1}& A_1          & \dots & 0^{2\times 2} \\
    \vdots       & \vdots       & \ddots& \vdots        \\
    0^{2\times 1}& 0^{2\times 2}& \dots & A_r 
  \end{bmatrix},\,\,A_j:=\begin{bmatrix}0 & \omega j \\ -\omega j & 0\end{bmatrix}},
\end{equation}
where $A\in\mathbb{R}^{m\times m}$ contains $r$ sub-matrices $A_j$ and $0^{i\times j}$ is a zero matrix of $i$ rows and $j$ columns. In matrix $A$, the top left entry is zero, the diagonal entries are $A_1,\dots,A_r$, the remaining entries are zeros.

The output matrix\vspace*{-3ex}
\begin{equation}\label{eq:mat_C}
  C=(1/T)\Big[1 \,\,\, \overbrace{\begin{matrix}1 & 0 &\cdots & 1 & 0\end{matrix}}^{2r}\Big],
\end{equation}
where $C\in\mathbb{R}^m$ (the first value in the first column is one, the pattern one--zero is then repeated $2r$ times).


%\begin{equation}\label{eq:state-details}\begin{split}
%  A&=\left[\begin{array}{cccc}
%    0&                     &       & \makebox(-5,-5){*}  \\
%     & A_1                 &       &  \\
%     & \makebox(-25,-15){*}& \ddots&  \\
%     &                     &       & A_r 
%  \end{array}\right],\,A_j:=\begin{bmatrix}0 & \omega j \\ -\omega j & 0\end{bmatrix},\\
%  C&=(1/T)\left[\begin{array}{cccccc}
%    1 & 1 & 0 &\cdots & 1 & 0
%  \end{array}\right],
%\end{split}\end{equation}
%where $\mathbf{q}\in\mathbb{R}^m$ with $m=2r+1$, $A\in\mathbb{R}^{m\times m}$ is the state transition matrix, and $C\in\mathbb{R}^m$ is the output matrix. In matrix $A$, the top left entry is zero, the diagonal entries are $A_1,\dots,A_r$, the remaining entries are zeros (*).

%The linear model in Eq.~(\ref{eq:state-perf}) allows us to include the control in the model of Eq.~(\ref{eq:fourier}).

To define the nominal control and the output matrix, we exploit the effect of variation of path and computation parameters on the energy. 
%We assume a variation in computations parameters $c_i^\sigma$ affects the instantaneous energy, i.e., different schedules of power-demanding computational tasks have different power drains from the computing hardware.
%\begin{lem}[Parameters, energy relation]\label{lem:new}
  Given $c_i(t)$ parameters at two following time instants $t\in\{t_j,t_{j+1}\}\subset\mathbb{R}_{\geq 0}$ s.t. $t_j<t_{j+1}$ for an arbitrary stage $\Gamma_i$, a change in parameters $c_i(t_j)\neq c_i(t_{j+1})$ results in different overall and instantaneous energies for path and computation parameters respectively.
%\end{lem}

%Apps.~\ref{app:proof-eqv}--\ref{app:proof-new} contain the proofs of Lemmas~\ref{lem:eqv}--\hyperref[lem:new]{2}.

%Using the same notation from Lem.~\ref{lem:new}, 
%
%\begin{equation}\label{eq:nom-cont}
%  \mathbf{u}(t_{j+1}):=\hat{\mathbf{u}}(t_{j+1})-\hat{\mathbf{u}}(t_j),
%\end{equation}
%for all time instants. 
The nominal control and input matrix in Eq.~(\ref{eq:state-perf}) simply includes the change in energy for all time instants, i.e.,
\begin{equation}\label{eq:mat_B}{\small
  \mathbf{u}(t_{j+1})\hspace*{-.5ex}:=\hspace*{-.5ex}\hat{\mathbf{u}}(t_{j+1})\hspace*{-.5ex}-\hspace*{-.5ex}\hat{\mathbf{u}}(t_j),\,\,\,B=\begin{bmatrix}
      0^{1\times\rho} & 1      & \cdots & 1      \\
      0^{1\times\rho} & 0      & \cdots & 0      \\ 
      \vdots          & \vdots & \ddots & \vdots \\
      0^{1\times\rho} & 0      & \cdots & 0   
  \end{bmatrix}},
\end{equation}
shifts the base frequency $\alpha_0$ assuming the energy of the computations does not alter the other frequencies. $B\in\mathbb{R}^{m\times n}$ with $n:=\rho+\sigma$ contains zeros but in the first row where the first $\rho$ columns are zeros and the remaining $\sigma$ are ones. Different combinations of $\mathbf{u}$ with matrix $B$ in Eq.~(\ref{eq:mat_B}) are possible %, as we discuss briefly in 
{\color{blue}(see }Section~\ref{sec:conclusion}{\color{blue})}.
The dynamics in Eqs.~(\ref{eq:state-perf}--\ref{eq:mat_B}) additionally allows us to use state estimation techniques, such as the Kalman filter in Section~\ref{sec:repla-algo}, to refine the states $\mathbf{q}$ and model the energy of the aerial robot flying under diverse %atmospheric 
conditions.

{\color{blue}Matrices $A$ and $C$ are constructed such that t}he %Under favorable conditions, %the 
models in Eqs.~(\ref{eq:fourier}--\ref{eq:state-perf}) are equal
%\begin{lem}[Signal, output equality]\label{lem:eqv}Given 
when $\mathbf{u}$ is a zero vector %, matrices $A,C$ described by Eqs.~(\ref{eq:mat_A}--\ref{eq:mat_C}), 
and an initial guess $\mathbf{q}(t_0)=\mathbf{q}_0$ at initial time instant $t_0$
  {\color{blue}\begin{equation}
  {\color{black}\mathbf{q}_0=\begin{bmatrix}a_0 & a_1/2 & b_1/2 & \cdots & a_r/2 & b_r/2\end{bmatrix}',}
  \end{equation}}
  %$h$ in Eq.~(\ref{eq:fourier}) is equal to $y$ in Eq.~(\ref{eq:state-perf}).
%\end{lem}
%\begin{proof}
%The equality of the signal and output is achieved by a proper choice of the items of matrices $A,C$ and the initial guess $\mathbf{q}_0$. We refer the reader to Appendix~\ref{app:proof-eqv} for a formal proof, where we justify the choices of the items of the matrices and of the initial guess. 
%\end{proof}
%Appendix~\ref{app:proof-eqv} contains a proof of Lem.~\ref{lem:eqv}.
i.e., $h,y$ are %both 
harmonic signals with the same frequencies{\color{blue}. For further details see the first author's Ph.D. thesis~\cite{seewaldphdthesis}}.

$\hat{\mathbf{u}}$ in Eq.~(\ref{eq:mat_B}) is then a scale transformation
\begin{equation}
  \hat{\mathbf{u}}(t):=\mathrm{diag}(\nu_i)c_i(t)+\tau_i,
\end{equation}
where $\mathrm{diag}(x)$ is a diagonal matrix with items of a set $x$ on the diagonal and zeros elsewhere. $\nu_i:=\begin{bmatrix}\nu_{i,1}&\cdots&\nu_{i,n}\end{bmatrix}'$ and $\tau_i:=\begin{bmatrix}\tau_{i,1}&\cdots&\tau_{i,n}\end{bmatrix}'$ are scaling factors{\color{blue},} %that 
transform{\color{blue}ing} parameters %domain 
(see Definition~\ref{def:stage}) to time and power domains.

%For ease of notation, 
{\color{blue}W}e assume that the coverage time evolves linearly{ \color{blue}and that the }path parameters{ \color{blue}contribute to it equally.} $c_i^\rho$ can be {\color{blue}then} transformed into a time measure with scaling factors\begin{subequations}\label{eq:scale-traj}\begin{align}
  \nu_{i,j}&=\left((\overline{t}-\underline{t})/(\overline{c}_{i,j}-\underline{c}_{i,j})\right)/\rho,\\
  \tau_{i,j}&=\left(\underline{c}_{i,j}(\underline{t}-\overline{t})/(\overline{c}_{i,j}-\underline{c}_{i,j})+\underline{t}\right)/\rho,
\end{align}\end{subequations} 
$\forall j\in[\rho]_{>0}$ where $\overline{t},\underline{t}$ are time measures needed to complete the coverage with configurations $\underline{c}_i^\rho,\overline{c}_i^\rho$ ($\underline{\Gamma},\overline{\Gamma}$).

Similarly to Eq.~(\ref{eq:scale-traj}), computation parameters $c_i^\sigma$ can be transformed into an instantaneous energy measure with %scaling factors
\begin{subequations}\label{eq:scale-comp}\begin{align}
  \nu_{i,j}&=(g(\overline{c}_{i,j})-g(\underline{c}_{i,j}))/(\overline{c}_{i,j}-\underline{c}_{i,j}),\\
  \tau_{i,j}&=\underline{c}_{i,j}(g(\underline{c}_{i,j})-g(\overline{c}_{i,j}))/(\overline{c}_{i,j}-\underline{c}_{i,j})+g(\underline{c}_{i,j}),
\end{align}\end{subequations}
$\forall j\in[\rho+1,n]$. The function $g$ is detailed in Section~\ref{sec:mod-com} and quantifies the power of the computing hardware.

\subsection{Energy model for the computations}
\label{sec:mod-com}

Models for heterogeneous computing hardware in the literature often rely on analytical expressions~\cite{marowka2017energy,%goraczko2008energy%calore2015energy,
yang2017designing} or different techniques, such as regressional analysis~\cite{bailey2014adaptive,ma2012holistic,seewald2019coarse}, aiding the selection of hardware- or software-specific parameters. This section presents an energy model based on our early studies~\cite{seewald2019component,seewald2019coarse}, which relies on regressional analysis to quantify the computations energy of any configuration of computations $c_i^\sigma$ within the bounds (see Definition~\ref{def:stage}).

The model compromises an automatic modeling and profiling tool~\cite{seewald2019coarse} named \powprof{} distributed %~\cite{powprofiler} 
under the open-source MIT license. It is segmented into two layers. In the \emph{measurement layer}, the tool measures a discrete set of computation parameters and infers the energy of the remaining in the \emph{predictive layer} via a piecewise linear regression.

We assume there is at least one measuring device, i.e., shunt or internal power resistor, multimeter, or amperemeter, quantifying the power drain of a specific component, e.g., CPU, GPU, memory, etc., or of the entire computing hardware.

\begin{defn}[Measurement layer]\label{def:meas}
  Given a measuring device, computation parameters, and initial and final time instants, the \emph{measurement layer} is the function $\gamma:\mathbb{Z}_{>0}\times\mathbb{Z}^\sigma\times\mathcal{T}\rightarrow\mathbb{R}$ that returns an energy measure.
\end{defn}

Here, the notation $\mathcal{T}$ encloses all the time intervals from initial $t_0$ to final $t_f$, i.e., $\mathcal{T}:=[t_0,t_f]$.

\begin{defn}[Predictive layer]\label{def:pred}
  Given a measuring device and computation parameters, the \emph{predictive layer} is the function $g:\mathbb{Z}_{>0}\times\mathbb{Z}^\sigma\rightarrow\mathbb{R}$ that returns an energy measure.
\end{defn}

The energy measures in Definitions~\ref{def:meas}--\hyperref[def:pred]{2} can be either average expressed in watts or overall expressed in joules. Additionally, the \powprof{} tool supports the battery SoC detailed in Section~\ref{sec:mod-bat}. The function $g$ in Definition~\ref{def:pred} is contained in the %computations scaling 
factors in Eq.~(\ref{eq:scale-comp}), assuming the computations energy behaves linearly between $\underline{c}_i^\sigma$ and $\overline{c}_i^\sigma$, otherwise
\begin{equation}\label{eq:piece-wise-reg}\begin{split}
  g(c_i^\sigma)=(&\gamma(\lceil c_i^\sigma\rceil,\mathcal{T}_1)-\gamma(\lfloor c_i^\sigma\rfloor,\mathcal{T}_2))\\(&c_i^\sigma-\lfloor c_i^\sigma\rfloor)/(\lceil c_i^\sigma\rceil-\lfloor c_i^\sigma\rfloor)+\gamma(\lfloor c_i^\sigma\rfloor,\mathcal{T}_2),
\end{split}\end{equation}
where notation $\lceil c_i^\sigma\rceil,\lfloor c_i^\sigma\rfloor$ indicates two adjacent measurement layers, and $\mathcal{T}_1,\mathcal{T}_2$ are the corresponding two time intervals. {\color{blue}M}easuring device in $\gamma$ and $g$ is {\color{blue}not explicitly stated in Eq.~(\ref{eq:piece-wise-reg})}.

\vspace*{-1.4ex}
\subsection{Battery model}
\label{sec:mod-bat}

The battery model predicts the battery SoC in the function of a given load at future time 
instants. There are multiple models in the literature~\cite{rao2003battery} with varying complexity {\color{blue}and} accuracy %, and ease of implementation 
ranging from accurate but costly physical models~\cite{%moura2017battery,
marcicki2013design}, to abstract models~\cite{%xing2014state,
%he2011evaluation,
hinz2019comparison,mousavi2014various} %that have
{\color{blue}with} compelling trade-offs in terms of the latter two. 
We model a Li-ion battery %of an aerial robot 
in-flight with an abstract ``Rint'' ECM in the literature~\cite{%he2011evaluation,
hinz2019comparison,mousavi2014various}.

The battery SoC changes according to~\cite{hasan2018exogenous%,zhang2018online
}, i.e.,
\begin{equation}\label{eq:batdyn}
  \dot{b}(y(t))=-k_bI(y(t))/Q_c,
\end{equation}
where $I(y(t))\in\mathbb{R}$ is the internal current measured in amperes, $y(t)\in\mathbb{R}_{\geq 0}$ the power drain, and $Q_c\in\mathbb{R}$ the battery constant nominal capacity measured in amperes per hour. $k_b$ is a battery coefficient added to~\cite{hasan2018exogenous%,zhang2018online
} and derived experimentally. The ``Rint'' circuit models the battery as a perfect voltage source connected with a resistor $R_r\in\mathbb{R}$ measured in ohm, representing the battery resistance. The voltage on the extremes of ECM respects $V_e=V-R_rI$, where $V,V_e\in\mathbb{R}$ are the internal and external battery voltages measured in volts. The former can be retrieved from the battery data sheet~\cite{hinz2019comparison} and depends on the SoC~\cite{hasan2018exogenous}.

If the voltage %of the power drain 
is stable, Kirchhoff's circuit laws lead to $V_sI_l=V_eI$, where $I_l$ is the current required by the load %measured 
in amperes. Combining $V_e,V_sI_l$ results in the %quadratic 
expression $R_rI^2-$ $VI+V_sI_l=0$. Solving the expression utilizing the negative solution (when $I_l$ is zero, $I$ should also be zero) %leads to% 
results in 
\begin{equation}\label{eq:batdyn2}
I(y(t))=(V-\sqrt{V^2-4R_ry(t)})/(2R_r).
\end{equation} 
%as in Lem.~\ref{lem:bat}.
%
%\begin{lem}[Battery SoC]\label{lem:bat}
%  Given the internal battery voltage $V\in\mathbb{R}$ measured in volts, resistance $R_r$ in ohms, constant nominal capacity $Q_c$ in amperes per hour, and 
%thus given a battery coefficient $k_b$, the \emph{battery SoC} evolves
%\begin{equation*}\label{eq:batdyn}
%  \dot{b}(t)=-k_b\left(V-
%  \sqrt{
%    V^2-
%    4R_ry(t)}
%  \right)/(2R_rQ_c).
%\end{equation*}
%\end{lem}

%App.~\ref{app:proof-bat} contains the proof of Lem.~\ref{lem:bat}. 

Eq.~(\ref{eq:state-perf}) states that the output $y$ evolves in $\mathbb{R}$, %conflicting with the the findings in this section. 
yet, aerial robots usually use a battery.
We thus use instead
%\begin{defn}[Output constraint]\label{def:const}
\begin{equation}\label{eq:output-const}
  {\small\mathcal{Y}(t):=\{y\mid y\in[0,b\,Q_cV]\subseteq{\mathbb{R}_{\geq 0}}\},} 
\end{equation}
%the \emph{output constraint}, 
where $b\,Q_cV$, the maximum instantaneous energy %consumption
measured in watts, is derived from Eq.~(\ref{eq:batdyn}--\ref{eq:batdyn2}).
%\end{defn}

%Let us consider for practical reasons the discretized version of the system in Eq.~\ref{eq:state-perf}. 

%Let us suppose that at time instant $k$ the plan reached the $i$-th stage $\Gamma_i$ and the control
%\begin{equation}\label{eq:state-control2}
%  \mathbf{u}_k=\begin{bmatrix}c_k^\rho & c_k^\sigma\end{bmatrix}^T,
%\end{equation}
%where $\mathbf{u}_k\in\mathbb{R}^n$ with $n=\rho+\sigma$ differs from the nominal control $\mathbf{u}$ in Eq.~(\ref{eq:state-perf}). We include the control in the nominal control exploiting the following observation. 

%We observe that a change in path parameters affects the energy indirectly. It alters the time when the UAV reaches the final point $\mathbf{p}_{\Gamma_l}$. We use this information later in the algorithm to check that the battery discharge time is greater and replan the path parameters accordingly. A change in computation parameters affects the energy directly. It alters the instantaneous energy consumption as more computations require more power (and vice versa). We replan the computation parameters to maximize the instantaneous energy consumption against the maximum battery discharge rate.

%The nominal control and the input matrix
%\begin{equation}\label{eq:state-control}\begin{split}
%  \mathbf{u}&=(\hat{\mathbf{u}}_k-\hat{\mathbf{u}}_{k-1}),\,\,\,\hat{\mathbf{u}}_k:=\mathrm{diag}(\nu_i)\mathbf{u}_k+\tau_i,\\
%  B&=\begin{bmatrix} 0 & \cdots & 0 & 1 & \cdots & 1 \\ 
%    & & & \makebox(-15,-3){*} & &\end{bmatrix}.
%\end{split}\end{equation}
%The matrix $B\in\mathbb{R}^{m\times n}$ contains zeros (*) except the first row where the first $\rho$ columns are still zeros and the remaining $\sigma$ are ones. $\hat{\mathbf{u}}_k$ is a scale transformation with $\nu_i=\begin{bmatrix}\nu_i^\rho & \nu_i^\sigma\end{bmatrix}^T$ and $\tau_i=\begin{bmatrix}\tau_i^\rho & \tau_i^\sigma\end{bmatrix}^T$ scaling factors quantifying the contribution to the plan of a given parameter in terms of time for the first $\rho$ parameters, and power for the remaining $\sigma$ (we use the same notation for the path and computation scaling factors as for the parameters). The nominal control $\mathbf{u}$ is then the difference of these contributions of two consecutive controls $\mathbf{u}_{k-1},\mathbf{u}_k$ applied to the system. $B\mathbf{u}$ merely includes the difference in power into the model in Eq.~(\ref{eq:state-perf}).
 
%Indeed an alteration of the path affects the overall flying time (and consequently the energy). An alteration the the computations affects the instantaneous energy consumption.

%We clarify how we derive the factors $\nu_i,\tau_i$ in the next two subsections.

%\subsection{Path parameters energy contribution}
%\label{sec:model}

%Eq.~(\ref{eq:state-control}) accounts for the energy due to the change of parameters $\mathbf{u}_k-\mathbf{u}_{k-1}$. For instance, when the trajectory $\varphi_1$ is a circle (see Fig.~\ref{fig:tee1}), a decrement in the trajectory parameter $c_{1,1}$--the radius of the circle--adds a negative contribution. It thus simulates the lowering of instantaneous energy consumption ($\nu_{1,1}c_{1,1}>\nu_{1,1}c_{1,1}^-$) for a given $\nu_{1,1}$, that is then summed to the first coefficient $\alpha_0$ in Eq.~(\ref{eq:state-details}), shifting the modeled energy.

%The set
%\begin{equation}\label{eq:area}
%  \mathcal{P}_i:=\{\mathbf{p}_k\mid\varphi_i(\mathbf{p}_k,c_{i}^\rho)\in\mathcal{C}_i\},
%\end{equation}
%delimits the area where the $i$-th path $\varphi_i$ is free to evolve using the path parameters $c_i^\rho$ (the gray area in Fig.~\ref{fig:tee1}). $\varphi_i$ is a function of the two coordinates and the path parameters, and is equal to zero when a point $\mathbf{p}_k$ is on the path. Physically, this means the UAV is flying exactly over the nominal trajectory. The path parameters allows to change the path. They are a way to alter the nominal trajectory in the initial plan and thus alter the energy by changing the flying time in the example in Fig.~\ref{fig:il-abs}.
%In fact, the algorithm uses the set from Eq.~(\ref{eq:area}) to find the path parameters such that the plan consisting of flying $\varphi_i$ has the highest energy, while still respecting the constraints. In Fig.~\ref{fig:tee1}, the parameter radius of the circle $c_{1,1}$ is replanned as, e.g., averse atmospheric conditions do not allow to terminate the plan.

%We derive the new position $\mathbf{p}_{k+1}$ computing the vector field $\nabla\varphi_i:=\begin{bmatrix}\partial\varphi_i/\partial x & \partial\varphi_i/\partial y\end{bmatrix}^T$, and the direction to follow in the form of velocity vector~\cite{de2017guidance}
%\begin{equation}\label{eq:pd}
%  \dot{\mathbf{p}}_d(\mathbf{p}_k):=E\nabla\varphi_i-k_e\varphi_i\nabla\varphi_i,\,\,\,E=\begin{bmatrix}
%    0&1\\-1&0
%  \end{bmatrix},
%\end{equation}
%where $E$ specifies the rotation (it influence the tracking direction), and $k_e\in\mathbb{R}_{\geq 0}$ the gain to adjusts the speed of convergence. The direction the velocity vector $\dot{\mathbf{p}}_d$ is pointing at is generally different from the course heading $\dot{\mathbf{p}}$ due to the atmospheric interferences (wind $w\in\mathbb{R}$ in the top of Fig.~\ref{fig:tee1}).

%The scaling factors for the path parameters from Eq.~(\ref{eq:state-control}) are derived empirically. For the example in Fig.~\ref{fig:tee1}, we can obtain the scaling factor $\nu_{1,1}$ measuring the time needed to compute the path with the lowest configuration $\underline{c}_1$, $\underline{t}$ and the highest $\overline{t}$. The variation of the control hence results in an approximate measure of the plans' time variation with factors
%\begin{equation}\label{eq:scale-traj}\begin{split}
%  \nu_{i,j}&=\left((\overline{t}-\underline{t})/(\overline{c}_{i,j}-\underline{c}_{i,j})\right)/\rho,\\
%  \tau_{i,j}&=\left(\underline{c}_{i,j}(\underline{t}-\overline{t})/(\overline{c}_{i,j}-\underline{c}_{i,j})+\underline{t}\right)/\rho,
%\end{split}\end{equation} 
%Whenever the trajectory parameters are not equally distributed, one can define $(y_{\overline{c}_i}-y_{\underline{c}_i})$ as a the highest (and lowest) levels of specific trajectory parameters. 
%$\forall j\in[\rho]^+$. Moreover, let the factors be zero when the parameters set $c_i^\rho=\{\emptyset\}$.

%\subsection{Computation parameters energy contribution}
%\label{sec:computations-model}

%Let us recall from Definition~\ref{def:mission} that the $i$-th stage $\Gamma_i$ of the plan $\Gamma$ contains the computation parameters which characterize the computations. We estimate the energy cost of these computations using \powprof{}, the open-source modeling tool adapted from earlier work on computational energy analysis~\cite{seewald2019coarse, seewald2019component}, and energy estimation of a fixed-wing UAV~\cite{seewald2020mechanical}. 

%For this purpose, we assume the UAV carries an embedded board that runs the computations. Our tool measures the instantaneous energy consumption of a subset of possible computation parameters within the computation constraint sets and builds an energy model: a linear interpolation, one per each computation. 

%The computations are implemented by software components, e.g., Robot Operating System (ROS) nodes in a ROS-based system~\cite{quigley2009ros}. The user implements these nodes such that they change the computational load according to node-specific ROS parameters--the computation parameters. In a generic software component system, the user maps the computational load to the arguments~\cite{seewald2019component}. In both cases, with ROS~\cite{zamanakos2020energy} or with generic software components system~\cite{seewald2019component}, the tool performs automatic modeling. For instance, if the computation is an object detector, a computation parameter $c_{1,2}$ might correspond to frames-per-second (fps) rate. The tool then measures power according to the detection frequency.

%We note that while the path can differ for each stage, the tasks remain the same. However, the user can inhibit or enable a computation varying its computation constraint set.

%Let us define $g:\mathbb{Z}_{\geq 0}\rightarrow\mathbb{R}_{\geq 0}$ as the instantaneous computational energy consumption value obtained using the tool.

%The scaling factors add the computational energy component to the model in Eq.~(\ref{eq:state-perf}). They are derived similarly to Eq.~(\ref{eq:scale-traj})
%\begin{equation*}\begin{split}
%  \nu_{i,j}&=(g(\overline{c}_{i,j})-g(\underline{c}_{i,j}))/(\overline{c}_{i,j}-\underline{c}_{i,j}),\\
%  \tau_{i,j}&=\underline{c}_{i,j}(g(\underline{c}_{i,j})-g(\overline{c}_{i,j}))/(\overline{c}_{i,j}-\underline{c}_{i,j})+g(\underline{c}_{i,j}),
%\end{split}\end{equation*}
%$\forall j\in[\rho+1,\rho+\sigma]$. Moreover, let the factors be zero when the parameters set $c_i^\sigma=\{\emptyset\}$.


\vspace*{-1.4ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Planning-Scheduling}  %
\label{sec:algo}               %
                               %
\begin{figure}[t]
  \footnotesize
  \begin{minipage}[l]{0.21\columnwidth}
    \caption{Alteration of the path parameter $c_{i,1}$, the radius of the circle (i.e., the alteration of the plan in Fig.~\ref{fig:il-abs}).
    }
    \label{fig:tee1}
  \end{minipage}\hfill
  \begin{minipage}[c]{0.77\columnwidth}
    \centering
    \vspace*{-4.5ex}
    \input{\figpath/new/traj2.tikz}
  \end{minipage}
  \vspace*{-4.5ex}
\end{figure}

This section solves the problem described in Section~\ref{sec:pbfor}. It provides a plan %$\Gamma$ 
and re-plans-schedules such plan energy-wise. %respectively
%in Sections~\ref{sec:cov-algo}--\hyperref[sec:repla-algo]{B}.

\vspace*{-1.4ex}
\subsection{Coverage}
\label{sec:cov-algo}

There are various approaches in the literature to solve CPP problems (e.g., Section~\ref{sec:pbfor}). Those that ensure %the 
completeness %of the cover 
are NP-hard~\cite{arkin2000approximation} and use cellular decomposition, dividing the free-space into sub-regions to be easily covered~\cite{choset2001coverage,galceran2013survey}.

An intuitive way to solve the problem is with a back-and-forth motion, sweeping the space delimited by $v$ we term $\mathcal{Q}^v$. Although abundant in both mobile ground-based~\cite{choset2001coverage%,%choset2005principles,
%lavalle2006planning
} and aerial~\cite{araujo2013multiple,%artemenko2016energy,
cabreira2018energy,difranco2015energy} robotics literature, the motion, called \emph{boustrophedon motion}~\cite{choset2001coverage}, is unsuitable for aerial robots broadly, especially for fixed-wing aerial robots. These robots have reduced maneuverability~\cite{dille2013efficient,mannadiar2010optimal,%xu2011optimal,
xu2014efficient} and are generally unable to fly quick turns~\cite{wang2017curvature}.

To address fixed wings and aerial robots generally, this section details a different motion with a wide turning radius. It is similar to another motion in the literature, the \emph{Zamboni motion}~\cite{araujo2013multiple}, but additionally allows variable CPP %at the very core of this work
{\color{blue} by dynamically altering the distance between the survey lines with the path parameters}. 
{\color{blue} Although cover variability is already considered in the literature~\cite{difranco2015energy}, it is limited to boustrophedon motion for rotary wings.}
The novel motion is termed \emph{Zamboni-like motion} and is composed of four primitive paths (see Definition~\ref{def:primitive}): two lines $\varphi_1,\varphi_2$ and two circles $\varphi_3,\varphi_4$.% (see Fig.~\ref{fig:zambo}). 

We assume the vertices $v_1,v_2,\dots$ are ordered from the top-left-most vertex %in 
clockwise% order
, the aerial robot can overfly the edges formed by the vertices, and ${}^{v_x}|_{v_y}$ indicates the edge formed by vertices $v_x,v_y$. 
Algorithm~\ref{alg2} details the procedure to generate the plan $\Gamma$ that covers $\mathcal{Q}^v$ %per each 
{\color{blue}at }discretized time step{\color{blue}s}, i.e., $\mathcal{T}:=\{t_0,t_0+h,\dots,t_f\}$ for a given step $h\in\mathbb{R}_{>0}$. The algorithm assumes that the line parallel to ${}^{v_1}|_{v_{|v|}}$ is always connected. %as it swipes $\mathcal{Q}^{v}$. %Nonetheless, a 
{\color{blue}C}omplex covering is possible by, e.g., dividing $\mathcal{Q}^{v}$ into cells to be easily covered and %subsequently 
covering each cell~\cite{choset2001coverage}.% with the novel motion.

%\begin{enumerate*}[label={(\alph*)},font={\textit}]
%  \item place a line $\varphi_i$ parallel to ${}^{v_1}|_{v_{|v|}}$ that intersects edges ${}^{v_{|v|}}|_{v_{|v-1|}},{}^{v_1}|_{v_2}$ (i.e., first and last),
%  \item place a circle $\varphi_{i+1}$ whose left most point lays at $\mathbf{p}_{\Gamma_i}$, the intersection of $\varphi_i$ and the edge ${}^{v_{|v|}}|_{v_{|v-1|}}$. $\varphi_{i+1}$ intersects $v$ again at $\mathbf{p}_{\Gamma_{i+1}}$,
%  \item place a line $\varphi_{i+2}$ parallel to $\varphi_i$ that intersects $v$ at $\mathbf{p}_{\Gamma_{i+1}},\mathbf{p}_{\Gamma_{i+2}}$,
%  \item finally, place a circle $\varphi_{i+3}$ whose right most point lays at $\mathbf{p}_{\Gamma_{i+2}}$ and intersects $v$ again at $\mathbf{p}_{\Gamma_{i+3}}$.
%\end{enumerate*}

%For ease of notation, the procedure assume that the polygon $v$ is constructed in such a way that the lines $\varphi_{k+1},\varphi_{k+3}$ are never disconnected. %These are
%\begin{subequations}\label{eq:line-gene}\begin{align}
%  \varphi_{k+1}&:=x-x_{\Gamma_1}-\lfloor i/4\rfloor x_\mathbf{d},\label{eq:v1}\\
%  \varphi_{k+3}&:=x-x_{\Gamma_2}-\lfloor i/4\rfloor x_\mathbf{d}\label{eq:v3},
%\end{align}
%\end{subequations}
%where $(x_\mathbf{p},y_\mathbf{p})=:\mathbf{p}$ for any point $\mathbf{p}$, and $\lfloor\,\cdot\,\rfloor$ is the integer division (it has a different meaning with parameters set $c_i$, see Eq.~\ref{eq:piece-wise-reg}). The circles are
%\begin{subequations}\label{eq:circ-gene}\begin{align}
%  \begin{split}\varphi_{i+1}:=(&x-x_{\Gamma_1}-r_1-\lfloor i/4\rfloor x_\mathbf{d})^2+\\ (&y-y_{\Gamma_1}-\lfloor i/4\rfloor y_\mathbf{d})^2-r_1^2,\end{split}\label{eq:v2}\\
%  \begin{split}\varphi_{i+3}:=(&x-x_{\Gamma_2}+r_2-\lfloor i/4\rfloor x_\mathbf{d})^2+\\ (&y-y_{\Gamma_3}-\lfloor i/4\rfloor y_\mathbf{d})^2-r_2^2,\label{eq:second-circ-gene}\end{split}
%\end{align}
%\end{subequations}
%where $r_1,r_2\in\mathbb{R}_{>0}$ s.t. $r_1>r_2>\underline{r}$ are radiuses. $r_1=r_2+x_\mathbf{d}/2$, whereas $r_2$ is in Eq.~(\ref{eq:r2}).

%Similarly, the triggering points are
%\begin{subequations}\label{eq:trigs-gene}\begin{align}
%  \mathbf{p}_{\Gamma_i}&\hspace*{-.35ex}:=(x_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}\lfloor i/4\rfloor x_\mathbf{d},y_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}\lfloor i/4\rfloor y_\mathbf{d}),\label{eq:t1}\\
%  \mathbf{p}_{\Gamma_{i+1}}&\hspace*{-.35ex}:=(x_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}2r_1+\lfloor i/4\rfloor x_\mathbf{d},y_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}\lfloor i/4\rfloor y_\mathbf{d}),\label{eq:t2}\\
%  \mathbf{p}_{\Gamma_{i+2}}&\hspace*{-.35ex}:=(x_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}2r_1+\lfloor i/4\rfloor x_\mathbf{d},y_{\Gamma_3}\hspace*{-.35ex}+\hspace*{-.35ex}\lfloor i/4\rfloor y_\mathbf{d}),\label{eq:t3}\\
%  \mathbf{p}_{\Gamma_{i+3}}&\hspace*{-.35ex}:=(x_{\Gamma_1}\hspace*{-.35ex}+\hspace*{-.35ex}2(r_1\hspace*{-.35ex}-\hspace*{-.35ex}r_2)+\lfloor i/4\rfloor x_\mathbf{d},y_{\Gamma_3}\hspace*{-.35ex}+\hspace*{-.35ex}\lfloor i/4\rfloor y_\mathbf{d})\label{eq:last-trig-gene}.
%\end{align}
%\end{subequations}

\begin{algorithm}[t]
  \begin{algorithmic}[1]
    \small
    %\STATE $j\gets-1$

    \FORALL{$t\in\mathcal{T}$}
      \color{blue}\STATE \textbf{if} $\mathbf{p}%(t)
      =\mathbf{p}_{\Gamma_l}${ in Definition~\ref{def:trigs}} \textbf{then return }$\Gamma$\vspace*{.3ex}\color{black}

%      \IF{$\mathbf{p}(i)=\mathbf{p}_{\Gamma_l}${ in Definition~\ref{def:trigs}}}
        
%        \RETURN{$\Gamma$}\vspace*{.3ex}
%      \ENDIF

      %\vspace*{.8ex}
      \color{blue}\IF{$\mathbf{p}%(t)
      =\mathbf{p}_{\Gamma_i}$}\color{black}
        \STATE $i\gets i+1$\vspace*{.3ex}
        \IF{$i\notin[n]_{>0}$}\label{alg2:cond}
          \STATE $i\gets 1$\vspace*{.3ex}
          \STATE $\varphi_{|\Gamma|+1}\gets$ line in Definition~\ref{def:paths} %in Eq.~(\ref{eq:v1}) 
          parallel to ${}^{v_1}|_{v_{|v|}}$ that\vspace*{.5ex} \hspace*{1em}intersects $\mathbf{p}_{|\Gamma|}$\vspace*{.3ex}

          \STATE $\mathbf{p}_{|\Gamma|+1}\gets$ other intersection %in Eq.~(\ref{eq:t1}) 
          of $\varphi_{|\Gamma|+1}$ and $v$\vspace*{.3ex}

          \STATE $\varphi_{|\Gamma|+2}\gets$ circle %in Eq.~(\ref{eq:v2}) 
          whose left most point lays on $\mathbf{p}_{|\Gamma|+1}$\vspace*{.3ex}\label{alg2:circ1}
          
          \STATE $\mathbf{p}_{|\Gamma|+2}\gets$ other inter. %in Eq~(\ref{eq:t2}) 
          of $\varphi_{|\Gamma|+2}$ and $v$\vspace*{.3ex}

          \STATE $\varphi_{|\Gamma|+3}\gets$ line %in Eq.~(\ref{eq:v3}) 
          par. to $\varphi_{|\Gamma|+1}$ that inter. $\mathbf{p}_{|\Gamma|+2}$\vspace*{.3ex}

          \STATE $\mathbf{p}_{|\Gamma|+3}\gets$ other inter. %in Eq~(\ref{eq:t3})
          of $\varphi_{|\Gamma|+3}$ and $v$\vspace*{.3ex}

          \STATE $\varphi_{|\Gamma|+4}\gets$ circle in Eq.\hspace*{.7ex}(\ref{eq:second-circ-gene}) 
          whose right most point lays\vspace*{.3ex} \hspace*{1em}on $\mathbf{p}_{|\Gamma|+3}$\vspace*{.3ex}\label{alg2:circ2}

          \STATE $\mathbf{p}_{|\Gamma|+4}\gets$ other inter. %in Eq~(\ref{eq:last-trig-gene}) 
          of $\varphi_{|\Gamma|+4}$ and $v$\vspace*{.3ex}\label{alg2:trig4}

          \vspace*{.8ex}
          \STATE $\Gamma\gets\Gamma\cup\{\Gamma_{|\Gamma|+1},\dots,\Gamma_{|\Gamma|+4}\}${ in Definitions~\ref{def:stage}--\hyperref[def:plan]{4}}\label{alg2:last}

        \ENDIF
      \ENDIF
    \ENDFOR
  \end{algorithmic}
  \caption{Zamboni-like motion for CPP}\label{alg2}
\end{algorithm}

To implement the variable CPP, the radius $r_2$ of the second circle $\varphi_{|\Gamma|+4}$ on Line~\ref{alg2:circ2}
\vspace*{-1ex}
\begin{equation}\label{eq:r2}
  {\small r_2(c_{i,1}):=\sqrt{\smash[b]{r^2+c_{i,1}}},}
  \vspace*{-.4ex}
\end{equation}
is expressed as a function of a path parameter $c_{i,1}\in(\underline{r}^2-r^2,0]$, relative to the last circle in each set of primitive stages. $r\in\mathbb{R}_{>0}$ is a given ideal turning radius along with the minimum radius (see Section~\ref{pb:cov-pb}). The center also changes
\begin{equation}\label{eq:second-circ-gene}
  \varphi_{|\Gamma|+4}:=(x-x_{\mathbf{p}_{|\Gamma|+3}}+r_2)^2+(y-y_{\mathbf{p}_{|\Gamma|+3}})^2-r_2^2,
\end{equation}
where $(x_\mathbf{p},y_\mathbf{p})=:\mathbf{p}$ for any point $\mathbf{p}$. Fig.~\ref{fig:tee1} illustrates the concept of $c_{i,1}$ altering the CPP. The radius of the first circle on Line~\ref{alg2:circ1} is then $r_1:=r+x_\mathbf{d}/2$ (i.e., the radiuses of the two circles ensure that the primitive paths are shifted of $\mathbf{d}$).% in Definition~\ref{def:primitive}).

Algorithm~\ref{alg2} initializes $i$ to minus one and builds the first four primitive functions $\varphi_1,\dots,\varphi_4$. The remaining $\Gamma$ is built with the shift $\mathbf{d}$ up to the final point $\mathbf{p}_{\Gamma_l}$. The initial point is $\mathbf{p}_{\Gamma_1}$, placed s.t. the line $\varphi_1$ is at the same distance from an eventual previous line, e.g., $x_{\mathbf{p}_{\Gamma_1}}=x_{v_1}+x_{\mathbf{d}}/2$ in Fig.~\ref{fig:zambo}.

\begin{figure}[t]
  \vspace*{-1ex}
  \footnotesize
  \begin{minipage}[l]{0.7\columnwidth}
    \centering
    \input{\figpath/new/traj3.tikz}
  \end{minipage}\hfill
  \begin{minipage}[l]{0.26\columnwidth}
    \caption{Zamboni-li- ke motion: $\overline{\Gamma}$ with four primitive paths (Lines~\ref{alg2:circ1}--\ref{alg2:trig4} in Algorithm~\ref{alg2}) can be re-planned ($\underline{\Gamma}$) {\color{blue}via} $r_2$.% in Eq.~(\ref{eq:r2}).
    }
    \label{fig:zambo}
  \end{minipage}
  \vspace*{-5ex}
\end{figure}

\subsection{Re-planning-scheduling}
\label{sec:repla-algo}

Past literature on planning-scheduling often relies on %optimal control and 
optimization {\color{blue} as well as heuristics-based} approaches~\cite{brateman2006energy,zhang2007low,ondruska2015scheduled,lahijanian2018resource}. We similarly derive an optimal control problem {\color{blue}and a greedy approach} returning the trajectory of parameters $c_i(\mathcal{T})$ with $\mathcal{T}:=[t_0,t_f]$ (see Definition~\ref{def:meas}). Since the final time %instant 
and the %exact 
value of the state $\mathbf{q}$ are not known, we use %a technique in the literature named 
output model predictive control (MPC) that derives the configuration for a finite horizon on an estimated state $\hat{\mathbf{q}}$, i.e., $t_f:=t_0+N$ for a given $N\in\mathbb{R}_{>0}$.%~\cite{rawlings2017model}. 
{\color{blue} We utilize MPC to derive the trajectory of the computation parameters and the greedy approach with heuristics remaining coverage time for the path parameters.}

\begin{algorithm}[t]
  \begin{algorithmic}[1]
    \small
    \FORALL{$t\in\mathcal{T}$}
      \makeatletter
      \setcounter{ALC@line}{15}
      \makeatother
      \color{blue}\STATE $\mathbf{q}(\mathcal{K}\setminus\{t+N\}),c_i^\sigma(\mathcal{K})\gets${ \vspace*{.3ex}solve NLP }$\argmax_{\mathbf{q}(k),c_i(k)}$ \vspace*{.7ex}\hspace*{1em}${l_f(\mathbf{q}(t+\hspace*{-.1ex}N),t+\hspace*{-.1ex}N)}+\hspace*{-.2ex}{\sum_{k\in\mathcal{K}}{l_d(\mathbf{q}(k),c_i(k),k)}}${ in Eq.~(\ref{eq:ocp-output-mpc}) \hspace*{1em}on }$\mathcal{K}=\{t,t+h,\dots,t+N\}$\vspace*{.3ex}\label{alg:mpc}
      
      \vspace*{.8ex}
      \color{black}\STATE $k\gets t$\vspace*{.3ex}\label{alg:bat1}
      \WHILE{$b_d(y(k))>0$}\vspace*{.3ex}
        \IF{$k+h\notin\mathcal{K}$}
          \STATE $\mathbf{q}(k+h)\gets${ solve model in Eq.~(\ref{eq:state-perf-q})}\vspace*{.3ex}\label{alg:evol}
        \ENDIF
        \STATE $b_d(y(k+h))\gets${ solve model in Eq.~(\ref{eq:batdyn})}\vspace*{.3ex}
        \STATE $k\gets k+h$\vspace*{.3ex}
      \ENDWHILE
      \STATE $t_b\gets k-t$\vspace*{.3ex}\label{alg:bat2}
      \vspace*{-2.4ex}
      %\STATE $t_s\gets(\mathrm{diag}(\nu_i^\rho)\vspace*{.3ex}c_i^\rho(t)+\tau_i^\rho)[\overbrace{\begin{matrix}1&1&\cdots&1\end{matrix}}^{\rho}]$\vspace*{.3ex}\label{alg:traj1}
      %\STATE $t_r\gets(t_s/\overline{t})(\overline{t}-t)$\vspace*{.3ex}
      \color{blue}\STATE $t_r\gets (\mathrm{diag}(\nu_i^\rho)\vspace*{.3ex}c_i^\rho(t)+\tau_i^\rho)[\overbrace{\begin{matrix}1&1&\cdots&1\end{matrix}}^{\rho}]-t$\vspace*{.3ex}\label{alg:traj1}
      \IF{$t_r>t_b$}
        \color{blue}\STATE $c_i^{\rho}(t)\gets${ find }$c_i^{\rho}${ with }$t_r\in[0,t_b]${, otherwise take }$\underline{c}_i^\rho$\vspace*{.3ex}\label{alg:traj2}
      \color{black}\ENDIF
      \vspace*{.8ex}
      \color{black}\STATE $\hat{\mathbf{q}}(t+h)\gets${ estimate }$\mathbf{q}${ in Eq.~(\ref{eq:state-perf-q}) with energy sensor }$\Upsilon(t)$\vspace*{.3ex}\label{alg:klm1}
      \color{black}\STATE $\hat{y}(t+h)\gets${ derive }$y${ from Eq.~(\ref{eq:state-perf-y}) with est. state }$\hat{\mathbf{q}}(t+h)$\vspace*{.3ex}\label{alg:klm2}
    \ENDFOR
  \end{algorithmic}
  \caption{Coverage re-planning-scheduling}\label{alg}
\end{algorithm}

An optimal control problem (OCP) that selects the highest configuration of {\color{blue} $c_i^\rho$} and respects the constraints, with $\mathbf{q}(t)$ and $c_i(t)$ the state and parameters trajectories
\begin{subequations}\label{eq:ocp-output-mpc}\begin{align}
  \max_{\mathbf{q}(t),c_i(t)}&{l_f(\mathbf{q}(t_f),t_f)+\int_{t_0}^{t_f}{l(\mathbf{q}(t),c_i(t),t)\,dt}},\label{eq:ocp-costs}\\
  \text{s.t. }\dot{\mathbf{q}}&=f(\mathbf{q}(t),c_i(t),t),\label{eq:dyn-evol}\\
  c_{i,j}(t)&\hspace*{-.2ex}\in\hspace*{-.2ex}\mathcal{C}_{i,j},\,c_{i,\rho+k}(t)\hspace*{-.2ex}\in\hspace*{-.2ex}\mathcal{S}_{i,k}\,\forall j\hspace*{-.2ex}\in\hspace*{-.2ex}[\rho]_{>0},\,k\hspace*{-.2ex}\in\hspace*{-.2ex}[\sigma]_{>0},\label{eq:state-cont-const-mpc}\\
  \mathbf{q}(t)&\hspace*{-.2ex}\in\hspace*{-.2ex}\mathbb{R}^m,\,y(t)\hspace*{-.2ex}\in\hspace*{-.2ex}\mathcal{Y}(t),\label{eq:batt-const-mpc}\\
  \mathbf{q}(t_0)&=\hat{\mathbf{q}}_0\,\,\,\text{given (last estimated state)},\text{ and}\label{eq:ocp-outp-mpc-state-est}\\
  b(t_0)&=b_0\,\,\,\text{given}\label{eq:ocp-outp-bat},
\end{align}\end{subequations}
where $l:\mathbb{R}^m\times\mathcal{C}_i\times\mathcal{S}_i\times\mathbb{R}_{\geq 0}\rightarrow\mathbb{R}$ is a given initial cost function with the quadratic expression
\vspace*{-.5ex}
\begin{equation}\label{eq:insta-cost-mpc}
  l(\mathbf{q}(t),c_i(t),t)=\mathbf{q}'(t)Q\mathbf{q}(t)+c_i'(t)Rc_i(t),
  \vspace*{-.5ex}
\end{equation}
where $Q\in\mathbb{R}^{m\times m},R\in\mathbb{R}^{n\times n}$ are given positive semidefinite matrices.%, resulting in the convexity of the cost $l$~\citep{nocedal2006numerical}. A useful property to guarantee a solution~\citep{beck2014introduction}.
The final cost function $l_f:\mathbb{R}^m\times\mathbb{R}_{> 0}\rightarrow\mathbb{R}$ is also a quadratic expression %but with no control %~\cite{rawlings2017model}
\vspace*{-.5ex}
\begin{equation}\label{eq:final-cost-mpc}
  l_f(\mathbf{q}(T),T)=\mathbf{q}'(T)Q_f\mathbf{q}(T), 
  \vspace*{-.5ex}
\end{equation}
where $Q_f\in\mathbb{R}^{m\times m}$ is a given positive semidefinite matrix.

Eq.~(\ref{eq:dyn-evol}) is the model in Eq.~(\ref{eq:state-perf}). {\color{blue}It} requires a value of the period $T$, which is %simply 
the time needed to fly the four primitive paths in the Zamboni-like motion{\color{blue}, or }%, i.e., 
the time elapsed between two positive evaluations of the condition on Line~\ref{alg2:cond}.

Eq.~(\ref{eq:state-cont-const-mpc}) are the parameters constraints sets in Definition~\ref{def:stage}. Eq.~(\ref{eq:batt-const-mpc}) are the state and output constraints %in Eq.~(\ref{eq:output-const}) 
that evolve the battery model in Eq.~(\ref{eq:batdyn}). Eq.~(\ref{eq:ocp-outp-mpc-state-est}) is the state guess estimated via state estimation % (e.g., linear Kalman filter)
(%the very 
first estimate is given). Eq.~(\ref{eq:ocp-outp-bat}) is the initial battery SoC from, e.g., flight controller.

Line~\ref{alg:mpc} in Algorithm~\ref{alg} contains a transcribed version of the OCP in Eq.~(\ref{eq:ocp-output-mpc}) into a nonlinear program (NLP) that can be %easily 
solved with available NLP solvers%~\cite{rawlings2017model}
. Its solution leads to both trajectories of {\color{blue} computation} parameters and states for future $N$ instants. Here, the sets $\mathcal{K},\mathcal{T}$ have possibly different steps $h$ (not to be confused with the altitude){\color{blue}: 
the set $\mathcal{K}$ is used for the numerical simulation, whereas $\mathcal{T}$ is for re-planning, meaning that $h$ tunes the precision and the frequency of re-planning for $\mathcal{K}$ and $\mathcal{T}$ respectively.}
The functions $l_d,b_d$ are the discretized versions of Eq.~(\ref{eq:insta-cost-mpc}) and Eq.~(\ref{eq:batdyn}).%, with, e.g., Runge-Kutta or Euler methods%~\cite{iserles2009first}.

Lines~\ref{alg:bat1}--\ref{alg:bat2} estimate the time needed to completely drain the battery, exploiting the SoC already predicted previously on Line~\ref{alg:mpc}. The {\color{blue}path parameters and thus the} coverage is then re{\color{blue}-}planned accordingly on Lines~\ref{alg:traj1}--\ref{alg:traj2} using {\color{blue} the heuristics with the} %Lem.~\ref{lem:new} and 
scaling factors from Eq.~(\ref{eq:scale-traj}). 
{\color{blue} Concretely, these lines implement the greedy approach by decreasing the path parameters of a given value $\delta_i$ or similarly increasing the parameters when $t_r\leq t_b$ within the bounds (this latter analogous case is not shown explicitly in Algorithm~\ref{alg2} but implemented in Section~\ref{sec:experimental})}.
Lines~\ref{alg:klm1}--\ref{alg:klm2} estimate the %energy model's 
state with %current 
energy sensor reading $\Upsilon$, {\color{blue}using}, e.g., %linear 
Kalman filter%~\cite{kalman1960new}
.

Algorithm~\ref{alg} implements Eq.~(\ref{eq:ocp-output-mpc}) for the purpose of energy-aware re-planning-scheduling of $\Gamma$ from Algorithm~\ref{alg2}, i.e, Lines~\ref{alg:mpc}--\ref{alg:klm2} continue after Line~\ref{alg2:last} in Algorithm~\ref{alg2}.

%The main purpose of the algorithm is to output a valid control sequence $\mathbf{u}:=\{\mathbf{u}_0,\mathbf{u}_1,\dots\}$ at each time step given an initial plan $\Gamma$ and to guide the UAV on the path resulting from such sequence--to solve Problem~\ref{pb}.

%A valid control sequence has to respect the energy constraints. We consider some realistic constraints to the energy of a flying UAV in the following subsection.

%\subsection{Output and control constraint sets}

%We stated earlier the output $y$--the instantaneous energy consumption--evolves in $\mathbb{R}$. This is generally untrue. Physical UAVs are bounded by strict energy budgets due to battery limitations.

%Let us hence consider the state of charge (SoC) $b$ of a UAV battery with a simplistic difference equation~\cite{seewald2020mechanical}
%\begin{equation}\label{eq:bat}
%  b_k=b_{k-1}-k_b\left(V-
%  \sqrt{
%    V^2-
%    4R_ry_k}
%  \right)/(2R_rQ_c),
%\end{equation}
%where $k_b$ is the battery coefficient determined experimentally,  $V\in\mathbb{R}$ is the internal battery 
% and $\tilde{V}\in\mathbb{R}$ the stabilized 
%voltage measured in volts, $R_r\in\mathbb{R}$ the resistance measured in ohms, and $Q_c\in\mathbb{R}$ the constant nominal capacity measured in amperes per hour. 

%\begin{defn}[Output, control constrain sets]\label{def:const}
%The output constrain set is then the set
%\begin{equation*}
%  \mathcal{Y}_k:=\{y_k\mid y_k\in[0,b_kQ_cV]\subseteq{\mathbb{R}_{\geq 0}}\},
%\end{equation*}
%and $b_kQ_cV$ is the maximum instantaneous energy consumption.

%The control constraint set is the path constraint set for the path parameters and computation constraint sets for the computation parameters (Definition~\ref{def:mission})
%\begin{equation*}
%  \mathcal{U}_k:=\begin{cases}
%    \mathcal{C}_i & \text{for } c_{i,j} \text{ with } j\leq\rho\\
%    \mathcal{S}_{i,j-\rho} & \text{for } c_{i,j} \text{ with } \rho<j\leq\sigma
%  \end{cases}.
%\end{equation*}
%\end{defn}

%\subsection{Deployment algorithm}

%The algorithm first initializes the position, energy coefficients, and control (line~\ref{alg:init}). It updates the position at line~\ref{alg:pos}, using the expression from Eq.~(\ref{eq:pd}) and the velocity $v\in\mathbb{R}_{\geq 0}$. The expression depends on the path $\varphi_i$ from stage $\Gamma_i$. The algorithm iterates all the stages in the plan $\Gamma$ (line~\ref{alg:stages-loop}), and enters the next stage $\Gamma_{i+1}$ when the UAV reaches the triggering point $\mathbf{p}_{\Gamma_i}$ (FSM in Definition~\ref{def:mission}).

%The energy coefficients are updated at line~\ref{alg:evolution}, using the expression from Eq.~(\ref{eq:state-perf}). A priori state estimate $\hat{\mathbf{q}}_k$ is refined using a state estimator--such as Kalman filter (KF)~\cite{simon2006optimal}--and the data from an energy sensor (line~\ref{alg:kalman_end}).
%At line~\ref{alg:mpc}, the algorithm uses MPC to select the control $\mathbf{u}_k$ for a given horizon $N\in\mathbb{Z}_{>0}$ from the cost function (higher the horizon, higher the complexity and the robustness of the control to the output constraints)
%\begin{equation*}\label{eq:cost}\begin{split}
%  V_f(\mathbf{q}_k)&=l(\mathbf{q}_k,\mathbf{u}_k)=(1/2)\mathbf{q}_k^T\mathrm{diag}(C)\mathbf{q}_k,
%\end{split}\end{equation*}
%where $\mathrm{diag}(C)$ is a diagonal matrix with the items of $C$ from Eq.~(\ref{eq:state-details}).

%We note that at every step of the sum on line~\ref{alg:mpc}, the algorithm evolves the state to check if the output satisfies the output constraint set, and if the control satisfies the control constraint set. In particular, it performs a subroutine
%\begin{algorithmic}
%  \WHILE{$\overline{c}_i\notin\mathcal{U}_k,\, y_k\notin\mathcal{Y}_k$}\label{alg2:while}
%    \STATE $\overline{c}_i\gets\overline{c}_i-\delta$
%  \ENDWHILE
%  \STATE $\mathbf{u}_k\gets\overline{c}_i$
%\end{algorithmic} 
%where $\delta\in\mathbb{R}^\rho\times\mathbb{Z}_{\geq 0}^\sigma$ are reduction steps. Both conditions of the loop have to be respected. The maximum values of path and computation parameters are reduced by the steps if they don't meet the constraints.

%We finally note that one can express the tradeoffs between parameters (e.g., a decrement in the distance between the lines in a survey scenario is related to a decrement in the number of detections per second) enriching the control constraint set with the constraints
%\begin{equation*}
%  R_i\mathbf{u}_k-r_i\geq 0,
%\end{equation*}
%where $r_i\in\mathbb{R}^n$ and $R_i\in\mathbb{R}^{n\times n}$ expresses the relation between the parameters (if $R_i$ is the identity matrix, there is no relation between the parameters).

%\begin{figure*}
%  \centering
%  \vspace*{-4ex}
%  \begin{subfigure}{.4\textwidth}
%    \centering
%    \footnotesize
%    \input{\figpath/results/new_physics2/trajs3.tikz}
%    \caption{Path, parameters ($c_{i,1},c_{i,2}$) evolutions}
%    \label{fig:trajs}
%  \end{subfigure}\hspace*{3ex}
%  \begin{subfigure}{.54\textwidth}
%    \centering
%    \footnotesize
%    \input{\figpath/results/new_physics2/ener3.tikz}
%    \caption{Energies, model states ($\alpha_0,\dots\in\mathbf{q}$), and parameters ($T,b_0$) evolutions}
%    \label{fig:ener}
%  \end{subfigure}
%  \footnotesize
%  \caption{CPP with novel Zamboni-like motion (\hyperref[fig:trajs-I-static]{I},\hyperref[fig:trajs-II-static]{II}) and Planning-scheduling of CPP and ground patterns detections with PedNet CNN (\hyperref[fig:trajs-dyn-i]{i},\hyperref[fig:trajs-dyn-ii]{ii}) in terms of the path, energies, and plans-schedules under different conditions (\hyperref[fig:trajs-I-static]{I}--\hyperref[fig:trajs-dyn-i]{i},\hyperref[fig:trajs-II-static]{II}--\hyperref[fig:trajs-dyn-ii]{ii}): wind speed and direction, battery behavior, and parameters initial values.}
%  \label{fig:res}
%  \vspace*{-3ex}
%\end{figure*}
\begin{figure*}
  \vspace*{-4ex}
  \centering
  \footnotesize
  \input{\figpath/results/new_physics2/new_trajs-ener_I-II.tikz}
  \captionsetup{labelfont={color=blue}}
  \vspace*{-.6ex}
  \caption{\color{blue}CPP with Zamboni-like motion using two boundary configurations. In \hyperref[fig:stat]{a} are the trajectories of the coverage--the highest in \hyperref[fig:trajs-I-static]{I} and the lowest in \hyperref[fig:trajs-II-static]{II}. In \hyperref[fig:stat]{b} are the energy and the period evolutions for both \hyperref[fig:trajs-I-static]{I} and \hyperref[fig:trajs-II-static]{II} with different atmospheric conditions. In \hyperref[fig:stat]{c} are the states of the energy model for \hyperref[fig:trajs-I-static]{I}.}
  \label{fig:stat}
  \vspace*{-3ex}
\end{figure*}
\begin{figure*}
  %\vspace*{-4ex}
  \centering
  \footnotesize
  \input{\figpath/results/new_physics2/new_trajs-ener_LOWER_i-ii.tikz}
  \captionsetup{labelfont={color=blue}}
  \vspace*{-.6ex}
  \caption{\color{blue}
  Planning-scheduling of CPP and ground patterns detections% with PedNet CNN
  , utilizing the lowest configuration \hyperref[fig:trajs-I-static]{I} as a starting point in \hyperref[fig:trajs-dyn-i]{i} and the highest \hyperref[fig:trajs-II-static]{II} in \hyperref[fig:trajs-dyn-ii]{ii} while varying atmospheric (same as Fig.~\ref{fig:stat}) and battery conditions. In \hyperref[fig:dyn]{a} are the re-planned trajectories, in \hyperref[fig:dyn]{b} the parameters, and in \hyperref[fig:dyn]{c} the energy w.r.t. the battery.
  }
  \label{fig:dyn}
  \vspace*{-4ex}
\end{figure*}


\vspace*{-1.4ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Numerical Simulations} %
\label{sec:experimental}        %
                                %
%$\subsection{Experimental setup}
\vspace*{-.2ex}

Numerical simulations of Algorithms~\ref{alg2}--\ref{alg} in this section are implemented in \textsc{Matlab}\hspace{.5ex}(R) and are extended with the computations energy model on NVIDIA\hspace{.5ex}(R) Jetson Nano\hspace{.5ex}(TM) heterogeneous computing hardware. These simulations complement early data of physical flights of a static coverage plan with the open-source Paparazzi flight controller%~\cite{papa}
.
The computing hardware carries a camera as a peripheral and is evaluated independently of the aerial robot with \powprof{} (see Section~\ref{sec:mod-com}). The scheduler, implemented using the Robot Operating System (ROS) middleware%~\cite{quigley2009ros}
, varies a computation parameter $c_{i,2}$ relative to the ground patterns detection rate from two to ten frames per second (FPS). The detection uses PedNet, a Convolutional Neural Network (CNN)~\cite{ullah2018pednet}, also implemented using ROS. The planner varies the path parameter $c_{i,1}$ %in %Eq.~(\ref{eq:r2}) 
between zero and -1000 (i.e., the planner-scheduler is the concrete implementation of Algorithms~\ref{alg2}--\ref{alg}). The set of parameters is unaltered through the flight, i.e, $c_i:=\begin{bmatrix}c_{i,1}&c_{i,2}\end{bmatrix}',\forall i${\color{blue}, along $\delta_i$ %utilized 
in the greedy approach}. 

%The algorithm that we presented in this paper is motivated by a periodic behavior of empirical data on energy consumption (see the subfigures of Fig.~\ref{fig:il-abs}). 
Fig.~\ref{fig:il-abs} details the data of the physical flight  
%We collected these data flying Opterra, a fixed-wing UAV that we adapted for an agricultural scenario. The UAV was flying 
in standard atmospheric conditions. 
Fig.~\ref{fig:stat}{\color{blue}--\ref{fig:dyn}} extends the flight with the computing hardware aided by a flight simulation implemented in \textsc{Matlab}\hspace{.5ex}(R). 
Upper-case roman numerals I,II indicate the plans are static (i.e., solely Algorithm~\ref{alg2}), lower-case i,ii exploit planning-scheduling as described in this letter.

%We later extended these UAV to carry a companion computer, NVIDIA Jetson Nano~\cite{nano}, running ROS. The companion computer has two ROS nodes; one detects hazards using PedNet, a Fully Convolutional Neural Network~\cite{ullah2018pednet}, and the other communicates with a ground station.

%\begin{figure}[t]
%  \centering
%  \footnotesize
%  \input{\figpath/results/new_physics2/trajs_revised.tikz}
%  \caption[Path of a static and dynamic plan]{Path simulations with variations of wind speed and direction. In \hyperref[fig:trajs-I-static]{5.I} and \hyperref[fig:trajs-II-static]{5.II} the path is static. It is dynamically replanned with the algorithm in \hyperref[fig:trajs-dyn-i]{5.i} and \hyperref[fig:trajs-dyn-ii]{5.ii}. The algorithm adapts path parameter radius of the circle $c_{1,1}$ and computation parameter fps rate $c_{1,2}$.}
%  \label{fig:trajs}
%\end{figure}
%\begin{figure}[h]
%  \centering
%  \footnotesize
%  \input{\figpath/results/new_physics2/ener_revised.tikz}
%  \caption[Energy models of different static and dynamic plans] {The energy models of the paths from Fig.~\ref{fig:trajs} for 200 seconds against the simulated data (\hyperref[fig:ener:static-I]{6.I} and \hyperref[fig:ener:static-II]{6.II}). Below are the energy evolutions from the algorithm (\hyperref[fig:ener-dyn-i]{6.i} and \hyperref[fig:ener-dyn-ii]{6.ii}). It replans the path when the final time and battery time do not match, and the computation when the battery is discharged.}
%  \label{fig:ener}
%\end{figure}
%\begin{figure}[h!]
%  \centering
%  \footnotesize
%  \input{\figpath/results/new_physics2/model.tikz}
%  \caption[Energy estimation and evolution of the state]{Energy estimation for the first 6 seconds on the left side, the evolution of the state $\mathbf{q}$ on the right.}
%  \label{fig:model}
%\end{figure}

%We implemented a realistic simulator to simulate the empirical data of a given plan and atmospheric conditions. We show the effects of different conditions in Fig.~\ref{fig:trajs}. 

Fig.~{\color{blue}\hyperref[fig:stat]{6a}--\hyperref[fig:dyn]{7a}} 
illustrate the same plan $\Gamma$ under different conditions. Flights \hyperref[fig:trajs-I-static]{I}--\hyperref[fig:trajs-dyn-i]{i} have a constant wind speed of five meters per second, a wind direction of zero degrees, and initial parameters $c_{i,1},c_{i,2}$ values of zero and ten (i.e., full $r_2$ and detection). Flights \hyperref[fig:trajs-II-static]{II}--\hyperref[fig:trajs-dyn-ii]{ii} (see added gray background for clarity) are the same but a wind direction of 90 degrees and the initial parameters values of -1000 and two (i.e., minimum $r_2$ and detection). 
{\color{blue} The initial values of path and computation parameters are chosen to represent the highest and lowest configurations in the search space in \hyperref[fig:trajs-I-static]{I}--\hyperref[fig:trajs-dyn-i]{i} and \hyperref[fig:trajs-II-static]{II}--\hyperref[fig:trajs-dyn-ii]{ii} respectively, modeling the behavior of the best- and worst-case scenarios.
Different search strategies are possible by, e.g., running an ideal instance of planning-scheduling prior to the flight.}

Fig.~%\ref{fig:ener}
{\color{blue}\hyperref[fig:stat]{6b}--\hyperref[fig:dyn]{7c}} %~\hyperref[fig:ener:static-I]{6.I}--\hyperref[fig:ener:static-II]{6.II} 
illustrates first the power ($\Upsilon$ on Line~\ref{alg:klm1} in Algorithm~\ref{alg}), and then the energy model ($y$ on Line~\ref{alg:evol}).
{\color{blue} Fig.~\hyperref[fig:stat]{6b}} %further 
details then the energy model's estimate (%see detail view for \hyperref[fig:ener:static-I]{I}--\hyperref[fig:ener:static-II]{II}
{\color{blue}${\hat{y}}$}) on an initial slice%of the model (${\hat{y}}$)
, power ($\Upsilon$), and period ($T$).
{\color{blue} Fig.~\hyperref[fig:stat]{6c}} illustrates the evolutions of the state $\mathbf{q}$ in time {\color{blue}for \hyperref[fig:ener:static-I]{I}}, concluding that approximately two periods suffice for a consistent %state 
estimate. 

Flight~\hyperref[fig:ener-dyn-i]{i} simulates a battery ({\color{blue}see} green line {\color{blue}in Fig.~\hyperref[fig:dyn]{7c}}, the battery behavior $b_0$) drop at approximately one minute and a half and four minutes and a half. Planner-scheduler optimizes the path in the proximity of the drops to ensure that the flight is completed, whereas it maximizes the parameter $c_{i,2}$ {\color{blue}(see Fig.~\hyperref[fig:dyn]{7b})} when the battery is discharging, respecting the output constraint% (Eq.~(\ref{eq:output-const}))
. Flight~\hyperref[fig:ener-dyn-ii]{ii} simulates the opposite scenario: the lowest configuration of parameters and no battery defects. The path parameter increases as soon as the algorithm has estimated enough data %(two periods $T$) 
and the computation parameter decreases matching the battery discharge rate. 
{\color{blue}
Assuming both the parameters are weighted equally, and the initial battery SoC is seventy percent, \hyperref[fig:trajs-I-static]{I} would not be able to complete the flight, and \hyperref[fig:trajs-II-static]{II} has a performance metric of zero (i.e., the lowest configuration of parameters throughout the flight).
Nonetheless, performance metrics of \hyperref[fig:trajs-dyn-i]{i} and \hyperref[fig:trajs-dyn-ii]{ii} are 13.05 and 2.24, whereas the average detection and coverage quality is approx. 45 and 35 percent for \hyperref[fig:trajs-dyn-i]{i}, and 62 and 87 percent for \hyperref[fig:trajs-dyn-ii]{ii}.}
For both cases, scaling factors are derived empirically %, 
{\color{blue}similarly to $\delta_i$ set to two hundred fifty}, 
the horizon $N$ is set to six seconds {\color{blue} as in} relevant literature~\cite{gavilan2015iterative,%kang2009linear,
stastny2018nonlinear%,chao2011collision
}, order $r$ is three% (see Fig.~\ref{fig:il-abs})
, and %the matrices 
$Q,R,Q_f$ are chosen such that the cost is %merely 
squared control. {\color{blue} $h$ is set to one-hundredth of a second and to one second for $\mathcal{K}$ and $\mathcal{T}$ respectively to allow sufficient precision and re-planning online.}
%\subsection{Algorithm evaluation}
%\subsubsection*{Periodic energy model}
%The figure
%{\color{blue} Fig.~\hyperref[fig:stat]{6c}} %further 
%details the energy model's estimate (see detail view for \hyperref[fig:ener:static-I]{I}--\hyperref[fig:ener:static-II]{II}) on an initial slice of the model (${\hat{y}}$), power ($\Upsilon$), and period ($T$). % We motivate this choice again with Fig.~\ref{fig:il-abs}, where the power spectrum subfigure shows that 3 frequencies are adequate. 
%The {\color{blue} right} detail of \hyperref[fig:ener:static-I]{I} illustrates the evolutions of the state $\mathbf{q}$ in time, concluding that approximately two periods suffice for a consistent %state 
%estimate. %With non-periodic signals, we observed that the estimator estimates primarily the first state $\alpha_0$ and it neglects the others. It hence approximates the non-periodicity with a linear model.

{\color{blue}
Additional results are reported~\cite{seewaldphdthesis} utilizing simulation capabilities of the Paparazzi flight controller. Data are split into two sets of four flights each, one similar to \hyperref[fig:trajs-dyn-i]{i} and the other to \hyperref[fig:trajs-dyn-ii]{ii}, i.e., initial parameters are at boundary configurations.
These results have an average performance metric of 1.81 and 1.24 for flights similar to \hyperref[fig:trajs-dyn-i]{i} and \hyperref[fig:trajs-dyn-i]{ii} respectively.}

Output MPC on Line~\ref{alg:mpc} relies on a software framework for nonlinear optimization called CasADi~\cite{andersson2012casadi%,andersson2012bcasadi,andersson2019casadi
}, and the popular NLP solver IPOPT~\cite{wachter2006implementation}; both are open-source.

%\subsubsection*{Implementation of the planning strategy}

%The practical implementation is based on observations of different variations of paths and computations. A variation of path alters the overall flying time, which we reflect in the factors $\nu_{1,1},\tau_{1,1}$ from Eq.~(\ref{eq:scale-traj}). We compare the remaining flight time with the time needed to completely deplete the battery from Eq.~(\ref{eq:bat}). We reduce or increase the parameter to optimize the battery time. The path parameter $c_{1,1}$ is equal for all the stages and it changes the radius of the first circle in the current period and therefore shifts the other paths accordingly (the change is illustrated in Fig.~\ref{fig:tee1}). It results in a shorter or longer distance between the survey lines and in an increment or reduction of the flying time respectively. The path constraint set is set to $\underline{c}_{1,1}=$ -1000 and $\overline{c}_{1,1}=$ 0 equal for all the stages.

%A variation of computations affects directly the power. We thus select the highest computation which satisfies the constraints from Definition~\ref{def:const} in the line~\ref{alg:mpc} of the algorithm. We observed a low effect on the power of the communication ROS node. Nevertheless, the detection node varies between 5 and 10 watts for the lowest and highest fps. We implemented fps rate parameter $c_{1,2}$ with factors  $\nu_{1,2},\tau_{1,2}$ mapping $c_{1,2}$ to the data from \powprof{}. The computation constraint set is set to $\underline{c}_{1,2}=$ 2 and $\overline{c}_{1,2}=$ 10 equal for all the stages.

%\subsubsection*{Dynamic adaptation of the path and computation parameters}

%Subfigures \hyperref[fig:trajs-dyn-i]{5.i}--\hyperref[fig:trajs-dyn-ii]{5.ii} in Fig.~\ref{fig:trajs} path-wise, and \hyperref[fig:ener-dyn-i]{6.i} and \hyperref[fig:ener-dyn-ii]{6.ii} of Fig.~\ref{fig:ener} energy-wise. For the first path (Subfigure \hyperref[fig:trajs-I-static]{5.I}) the plan starts at the highest configuration of parameters. 


\vspace*{-1.5ex}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions and Future Directions}  %
\label{sec:conclusion}                       %
                                             %
This letter provides a planning-scheduling approach for autonomous aerial robots.% powered by a limited power source, extending past literature. It proposes a novel coverage motion for variable CPP robust to aerial robots constraints such as the turning radius of fixed wings. Energy modeling in the letter exploits collected empirical data of the fixed-wing aerial robot flying static CPP and further incorporates the energy of the computing hardware via the \powprof{} tool. 
The approach compromises two algorithms: one derives a static coverage plan, whereas the other re-plans-schedules the plan on a finite horizon via MPC {\color{blue} and a greedy approach}. It evolves the state of the energy model while optimizing battery usage and remedying possible defects. The plan compromise multiple stages, where at each stage the aerial robot flies a path and runs the computations, allowing %further 
extensibility in terms of constructs and approaches.

{\color{blue}To enable physical experiments}, we are currently extending the results to a standard flight controller. %The guidance on the coverage, coverage with variable altitude, %(for, e.g., infrastructure inspections), 
%and distributed planning-scheduling merit additional investigation, as well as 
The study of the implications of planning-scheduling on other energy-critical mobile robots {\color{blue}merit additional investigation}. Here, our preliminary study led to possible savings~\cite{seewald2020beyond}, in line with relevant literature~\cite{ondruska2015scheduled,lahijanian2018resource}.
Further directions include {\color{blue}the use of a purely optimization-based technique, e.g., MPC derives both the path and computation parameters trajectories and} the study of different energy models.% Amongst others, these include aperiodic energy models, different linear combinations of the variations of parameters, and stage-dependent energy models.% In an unconventional setting with, e.g., multiple agents utilized for overall coverage, an agent-dependent model might be employed to achieve energy awareness.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
{\small\bibliographystyle{IEEEtran}  %
%\bibliography{../../books/phd-thesis/backmatter/references}}
\bibliography{energy-planning}}             %
%  
                                    
%\leavevmode\thispagestyle{empty}\newpage

%\appendices

% appendix, title all on one line
%\renewcommand{\thesectiondis}[2]{\Alph{section}:}

%\vspace*{-1ex}
%\section{Proof of Lem.~\ref{lem:eqv}}
%\label{app:proof-eqv}{\small

%The proof justifies the items of $A, C,$ and $\mathbf{q}_0$ in Lem.~(\ref{lem:eqv}), s.t. the coefficients of the series $a_0,\dots,b_r$ equal the coefficients $\alpha_0,\dots,\beta_r$ of the state $\mathbf{q}$.

%Firstly, it is convenient to re-write Eq.~(\ref{eq:fourier}) in complex form, with, e.g., $e^{it}=\cos{t}+i\sin{t}$. Given $t=\omega jt$, $\cos{\omega jt}=(e^{i\omega jt}+e^{-i\omega jt})/2$ and $\sin{\omega jt}=(e^{i\omega jt}-e^{-i\omega jt})/(2i)$ by substitution of $\sin{\omega jt}$ and $\cos{\omega jt}$ respectively~\cite{kuo1967automatic}. Then
%\vspace*{-.8ex}\begin{equation}\label{eq:proof-complex}\vspace*{-.8ex}
%  h(t)\hspace*{-.4ex}=\hspace*{-.4ex}a_0/T\hspace*{-.4ex}+\hspace*{-.4ex}(1/T)\sum_{j=1}^{r}{e^{i\omega jt}\hspace*{-.3ex}(a_j\hspace*{-.4ex}-\hspace*{-.4ex}ib_j)}\hspace*{-.4ex}+\hspace*{-.4ex}(1/T)\sum_{j=1}^{r}{e^{-i\omega jt}\hspace*{-.3ex}(a_j\hspace*{-.4ex}+\hspace*{-.4ex}ib_j)},\vspace*{-.8ex}
%\end{equation}
%where $i$ is this time the imaginary unit. 

%Secondly, the solution at $t$ of Eq.~(\ref{eq:state-perf}) can be expressed $\mathbf{q}=e^{At}\mathbf{q}_0$~\cite{ogata2002modern}. %Both the solution and the system in Eq.~(\ref{eq:state-perf}) are well established expressions derived using standard textbooks~\cite{kuo1967automatic, ogata2002modern}.
%Here, a method to solve the matrix exponential $e^{At}$ is the eigenvectors matrix decomposition method~\cite{moler2003nineteen} by exploiting the similarity transformation $A=VDV^{-1}$. The power series definition of $e^{At}$ implies $e^{At}=Ve^{Dt}V^{-1}$~\cite{moler2003nineteen}. 

%Within this expression, we consider the non-singular matrix $V$, whose columns are eigenvectors of $A$, $V:=[\begin{matrix}v_0 & v_1^0 & v_1^1 & \dots\end{matrix}$ $\begin{matrix}v_r^0 & v_r^1\end{matrix}]$, and the diagonal matrix of eigenvalues, $D=\mathrm{diag}(\lambda_0,\lambda_1^0,$ $\lambda_1^1,\dots,\lambda_r^0,\lambda_r^1)$. $V$ is built s.t. $\lambda_0$ is the eigenvalue associated with the first item of $A$. $\lambda_j^0,\lambda_j^1$ are the two eigenvalues associated with the block $A_j$. $Av_j=\lambda_jv_j\,,\forall j\in[m]_{>0}$, and so $AV=VD$.

%The approach in terms of Eq.~(\ref{eq:state-perf}) %, under the assumptions made in the lemma (the control is a zero vector);
%is $\dot{\mathbf{q}}=A\mathbf{q}$.
%The linear combination of the initial guess in Lem.~\ref{lem:new} and the generic solution of Eq.~(\ref{eq:state-perf})
%\vspace*{-1.6ex}\begin{subequations}\begin{align}
%  F\mathbf{q}(0)&=\gamma_0 v_0+\sum_{k=0}^{1}{\sum_{j=1}^{r}{\gamma_j v_j^k}},\\\vspace*{-.8ex}
%  F\mathbf{q}(t)&=\gamma_0 e^{\lambda_0 t} v_0+\sum_{k=0}^{1}{\sum_{j=1}^{r}{\gamma_j e^{\lambda_j t} v_j^k}}\label{eq:proof-comb},\vspace*{-.8ex}
%\end{align}\end{subequations}
%where $F:=\begin{bmatrix}1 & \cdots & 1\end{bmatrix}$ is simply a properly sized vector of ones. 

%Eq.~(\ref{eq:proof-comb}) is the linear combination of all the coefficients of the state at time $t$. By dividing the expression with the period
%\vspace*{-1.6ex}\begin{equation}\label{eq:proof-output}
%  F\mathbf{q}(t)/T\hspace*{-.4ex}=\hspace*{-.4ex}\gamma_0 e^{\lambda_0t}v_0/T+(1/T)\sum_{j=1}^r{\gamma_j e^{\lambda_j^0t}v_j^0}+(1/T)\sum_{j=1}^r{\gamma_j e^{\lambda_j^1t}v_j^1}.
%\end{equation}

%Finally, we prove that the eigenvalues $\lambda_0,\lambda_1^0,\lambda_1^1,\dots$ and eigenvectors in $v_0,v_1^0,v_1^1,\dots$ are s.t. Eq.~(\ref{eq:proof-output}) is equivalent to Eq.~(\ref{eq:proof-complex}).

%The matrix $A$ is a block diagonal matrix: its determinant is the multiplication of the determinants of its blocks $\det{(A)}=\det{(0)}\times\det{(A_1)}\times\cdots\times\det{(A_r)}$.

%The first terms of the Eq.~(\ref{eq:proof-complex}) and~(\ref{eq:proof-output}) match. The eigenvalue from $\det(0)=0$ is $\lambda_0=0$. The corresponding eigenvector can be chosen arbitrarily $(0-\lambda_0)v_0=\begin{bmatrix} 0 & \cdots & 0 \end{bmatrix}\,\,\,\forall v_0$, e.g., $v_0=\begin{bmatrix}1 & 0 & \cdots & 0\end{bmatrix}$. We find the value $\gamma_0$ of the vector $\gamma$ so that the terms are equal, e.g., $\gamma_0=\begin{bmatrix}a_0 & 0 & \cdots & 0\end{bmatrix}$. 

%All the terms in the sum of both the Eq.~(\ref{eq:proof-complex}) and~(\ref{eq:proof-output}) match. For the first block $A_1$, the eigenvalues are found by $\det(A_1-\lambda I)=0$. The polynomial $\lambda^2+\omega^2$, gives two complex roots, the two eigenvalues $\lambda_1^0=i\omega$ and $\lambda_1^1=-i\omega$. The eigenvector associated with the eigenvalue $\lambda_1^0$ is $v_1^0=\begin{bmatrix}0 & -i&1&0&\cdots&0\end{bmatrix}'$. The eigenvector associated with the eigenvalue $\lambda_1^1$ is $v_1^1=\begin{bmatrix}0&i&1&0&\cdots&0\end{bmatrix}'$. Again, we find the values $\gamma_1$ of the vector $\gamma$ such that the equivalences 
%\begin{equation}\begin{cases}
%  e^{i\omega t}(a_1-ib_1)&=\gamma_1 e^{i\omega t}v_1^0\\
%  e^{-i\omega t}(a_1+ib_1)&=\gamma_1 e^{i\omega t}v_1^1
%\end{cases},\end{equation}
%hold, e.g., $\gamma_1=\begin{bmatrix}b_1&a_1\end{bmatrix}$. 

%The proof for the remaining $r-1$ blocks is equivalent.

%The initial guess is constructed s.t. the sum of the coefficients is the same in both Eq.~(\ref{eq:proof-output}) and~(\ref{eq:proof-complex}). In the output matrix, the frequency $1/T$ accounts for the period% in Eq.~(\ref{eq:proof-complex}) and~(\ref{eq:proof-output}) and~(\ref{eq:fourier})
%. At time instant zero, the coefficients $b_j$ are not present, and the coefficients $a_j$ are doubled for each $j=[r]_{>0}$ (thus we multiply by one-half the corresponding coefficients in $\mathbf{q}_0$). To match the outputs $h(t)=y(t)$, or equivalently $F\mathbf{q}(t)/T=C\mathbf{q}(t)$, $C=(1/T)\begin{bmatrix}1 & 1 & 0 & \cdots & 1 & 0\end{bmatrix}$. Eq.~(\ref{eq:proof-output}) and~(\ref{eq:proof-complex}) are thus equal. Eq.~(\ref{eq:proof-complex}) is merely the complex form of Eq.~(\ref{eq:fourier}).

%\qed
%Periodicity is preserved with other linear combination of coefficients (for instance, $C=d\begin{bmatrix}1 & 0 & 1 & \cdots & 0 & 1\end{bmatrix}$, or $d\begin{bmatrix}1 & \cdots & 1\end{bmatrix}$ for a constant value $d\in\mathbb{R}$).
%}

%\vspace*{-1ex}
%\section{Proof of Lem.~\ref{lem:new}}
%\label{app:proof-new}{\small

%A change in computations parameters in Lem.~\ref{lem:new} results in different schedules on the computing hardware, which we assumed in Section~\ref{sec:intro} affects the instantaneous energy, i.e., computations are energy expensive computational tasks.

%A change in the path parameters in Lem.~\ref{lem:new} alters the flight time, and consequently, the energy. The proof quantifies this time: consider the plan $\overline{\Gamma}$ in Fig.~\ref{fig:zambo}. It is composed of four primitive paths and the highest configuration of path parameter $c_{i,1}$. We assume that the time to travel $\varphi_4(\overline{c}_{i,1})$ is $t_3\in\mathbb{R}_{>0}$, $\varphi_1,\varphi_3$, the two lines, is $2t_1\in\mathbb{R}_{>0}$, and $\varphi_2$ is $t_2\in\mathbb{R}_{>0}$. Further, assume that $v$ is covered merely by the set of primitive paths in Fig.~\ref{fig:zambo}. The coverage time is $t_{\overline{\Gamma}}=7(2t_1+t_2+t_3)+t_1$. 

%Conversely, assume the time needed to travel $\varphi_4(\underline{c}_{i,1})$ is $t_4\in\mathbb{R}_{>0}$. Then $t_{\underline{\Gamma}}=3(2t_1+t_2+t_4)+t_1$, and $t_{\overline{\Gamma}}>t_{\underline{\Gamma}}$. %even under the unrealistic assumption $t_3\approxeq t_4$.
%If $c_{i,1}(t_j),{c}_{i,1}(t_{j+1})$ are $\overline{c}_{i,1},\underline{c}_{i,1}$ in an arbitrary order, Lem.~\ref{lem:new} is satisfied. Furthermore, for any combination $c_{i,1}(t_j)\neq{c}_{i,1}(t_{j+1})$ Lem.~\ref{lem:new} is satisfied, i.e., each variation of $c_{i,1}$ alters $r_2$ in Eq.~(\ref{eq:r2}) and the length of the cover with the Zamboni-like motion.

%\qed
%}

%\vspace*{-1ex}
%\section{Proof of Lem.~\ref{lem:bat}}
%\label{app:proof-bat}{\small

%The proof justifies the expression in Lem.~\ref{lem:bat}.

 

%\qed

%}

%\leavevmode\thispagestyle{empty}\newpage
%\leavevmode\thispagestyle{empty}\newpage


\end{document}


%'\>o-O</'

